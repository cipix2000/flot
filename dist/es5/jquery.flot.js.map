{"version":3,"sources":["jquery.canvaswrapper.js","jquery.colorhelpers.js","jquery.flot.js","jquery.flot.saturated.js","jquery.flot.browser.js","jquery.flot.drawSeries.js","jquery.flot.uiConstants.js","jquery.flot.logaxis.js","jquery.flot.symbol.js","jquery.flot.flatdata.js","jquery.flot.navigate.js","jquery.flot.stack.js","jquery.flot.touchNavigate.js","jquery.flot.hover.js","jquery.flot.touch.js","jquery.flot.absRelTime.js","jquery.flot.axislabels.js","jquery.flot.selection.js","jquery.flot.composeImages.js","jquery.flot.legend.js"],"names":["$","generateKey","text","replace","Canvas","cls","container","element","getElementsByClassName","document","createElement","className","style","direction","position","left","top","appendChild","getContext","Error","this","context","pixelRatio","plot","browser","getPixelRatio","box","getBoundingClientRect","resize","width","height","SVGContainer","SVG","_textCache","prototype","restore","save","scale","clear","clearRect","render","cache","layerKey","hasOwnProperty","call","layer","getSVGLayer","layerCache","display","styleKey","styleCache","key","val","positions","i","active","rendered","splice","firstChild","removeChild","parentNode","length","measured","classes","svgElement","bottom","right","pointerEvents","createElementNS","setAttribute","getTextInfo","font","angle","textStyle","info","_typeof","variant","weight","size","lineHeight","family","indexOf","addTspanElements","textNode","createTextNode","maxWidth","setAttributeNS","fill","elementRect","getBBox","addText","x","y","halign","valign","transforms","textContent","cloneNode","push","textAlign","forEach","t","transform","baseVal","appendItem","tspan","offset","lines","split","childNodes","removeText","htmlYCoord","clearCache","window","Flot","jQuery","color","make","r","g","b","a","o","add","c","d","charAt","normalize","f","toString","join","clamp","min","value","max","parseInt","clone","extract","elem","css","toLowerCase","parent","nodeName","get","parse","str","res","m","exec","parseFloat","name","trim","lookupColors","aqua","azure","beige","black","blue","brown","cyan","darkblue","darkcyan","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkviolet","fuchsia","gold","green","indigo","khaki","lightblue","lightcyan","lightgreen","lightgrey","lightpink","lightyellow","lime","magenta","maroon","navy","olive","orange","pink","purple","violet","red","silver","white","yellow","defaultTickGenerator","axis","prev","ticks","start","saturated","saturate","floorInBase","tickSize","v","Number","NaN","multiplyAdd","defaultTickFormatter","precision","oldTickDecimals","tickDecimals","factor","Math","pow","formatted","round","decimal","decimalPrecision","substr","decimals","expRepTickFormatter","minSize","expPosition","floor","log","LN10","roundWith","toFixed","tenExponent","recomputePrecision","log10Value","abs","num","LOG10E","newPrecision","Plot","placeholder","data_","options_","plugins","hook","args","oldseries","series","parseData","processData","s","extend","options","data","axisNumber","obj","coord","n","allAxes","xaxes","concat","yaxes","filter","pos","c2p","used","x1","undefined","y1","cartesianAxisToCanvasCoords","p2c","getOrCreateAxis","axes","number","xaxis","yaxis","fillInSeriesOptions","neededColors","maxIndex","sc","colors","colorPool","colorPoolSize","variation","definedColors","colori","show","zero","prevSeries","updateAxis","Infinity","datamin","datamax","j","k","points","ps","p","format","topSentry","POSITIVE_INFINITY","bottomSentry","NEGATIVE_INFINITY","growOnly","datapoints","MAX_VALUE","exponentValue","computeRange","autoScale","defaultValue","required","bars","pointsize","mode","steps","inverseTransform","nullify","autoScaleMargin","isNaN","showTickLabels","above","below","centerX","centerY","insertSteps","fillColor","barWidth","grid","hooks","processDatapoints","margin","minBorderMargin","labelMargin","axisMargin","range","adjustSeriesDataRange","clickable","autoHighlight","xmin","xmax","interaction","ymin","ymax","_","surface","eventHolder","getPlaceholder","event","handler","priority","eventList","eventManager","sort","getSurface","eventData","unbind","bind","shutdown","clearTimeout","redrawTimeout","executeHooks","plotHeight","identity","getData","getAxes","isFinite","plotWidth","delta","tp","overlay","opts","autoScaleAxis","computeRangeForDataSeries","labelWidth","findNearbyItem","findNearbyInterpolationPoint","computeValuePrecision","legacyStyles","computeTickSize","label","MINOR_TICKS_COUNT_CONSTANT","uiConstants","TICK_LENGTH_CONSTANT","setupGrid","labelHeight","allocateAxisBoxFirstPhase","axisReserveSpace","lw","lh","isXAxis","tickLength","showTicks","showMinorTicks","gridLines","padding","innermost","outermost","each","found","fontSize","fontDefaults","fontSizeDefault","axisOptions","plotOffset","axisCount","allocateAxisBoxSecondPhase","boxPosition","adjustLayoutForThingsStickingOut","minMargin","radius","lineWidth","margins","reserveSpace","alignAxisWithGrid","ceil","isValid","showGrid","processOffset","borderWidth","axisOpts","allocatedAxes","grep","setTransformationHelpers","setEndpointTicks","measureTickLabels","widenMinMax","minimum","maximum","widen","wmin","widenedMinMax","autoScaledMin","autoScaledMax","setRange","tmp","reusePoints","noTicks","dec","norm","magn","processRawData","expectedPs","sqrt","minTickSize","ticksOption","setupTickFormatter","tickFormatter","slice","arguments","apply","setupTickGeneration","fixupNumberOfTicks","getAxisTickSize","tickGenerator","alignTicksWithAxis","otherAxis","niceTicks","extraDec","ts","test","setMajorTicks","every","oticks","children","hasClass","newTick","type","getEndpointPrecision","existing","snapRangeToTicks","canvas1","addEventHandler","canvas2","unshift","some","associatedSeries","notAllBarSeries","it","drawBackground","ctx","backgroundColor","drawGrid","drawSeries","draw","aboveData","triggerRedrawOverlay","ranges","from","to","fillStyle","getColorOrGradient","fillRect","drawMarkings","markings","xrange","yrange","xequal","yequal","markingsLineWidth","markingsColor","moveTo","subPixel","lineTo","stroke","alignPosition","drawTickBar","xoff","yoff","strokeStyle","beginPath","drawTickMarks","minorTicksNr","edges","xminor","yminor","v2","v1","step","tickColor","bw","bc","borderColor","translate","newLabelBox","nullBox","labelBoxes","overlapping","x11","y11","x12","y12","x21","y21","x22","y22","overlapsOtherLabels","previousLabelBoxes","labelBox","drawAxisLabel","tick","drawAxis","drawSeriesLines","drawSymbol","force","useAbsoluteBarWidth","computeBarWidth","align","horizontal","isFunction","minDistance","distance","dx","dy","dist","maxDistance","smallestDistance","axisy","axisx","mouseX","my","mouseY","maxx","maxy","point2","mx","item","datapoint","seriesIndex","posX","posY","seriesFilter","extractRange","x2","comparer","p1y","p2x","p2y","p1x","leftPoint","redrawOverlayInterval","drawOverlay","CustomEvent","getEventHolder","dispatchEvent","spec","defaultColor","l","co","brightness","opacity","addColorStop","gradient","windowSize","symbol","shadowSize","highlightColor","hoverable","mouseActiveRadius","octx","bindEvents","setData","getCanvas","getPlotOffset","canvasToCartesianAxisCoords","pointOffset","point","removeData","empty","clearTextCache","init","processOptions","fn","linearTickGenerator","multiply","bInt","result","base","getPageXY","e","doc","documentElement","X","clientX","pageXOffset","scrollLeft","clientLeft","Y","clientY","pageYOffset","scrollTop","clientTop","devicePixelRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","isSafari","HTMLElement","safari","pushNotification","isMobileSafari","navigator","userAgent","match","isOpera","opr","addons","opera","isFirefox","InstallTrigger","isIE","documentMode","isEdge","StyleMedia","isChrome","chrome","webstore","isBlink","CSS","DrawSeries","plotLine","xoffset","yoffset","prevx","prevy","y2","plotLineArea","fillTowards","ypos","areaOpen","segmentStart","segmentEnd","x1old","x2old","lineJoin","dashes","setLineDash","decimate","getFillStyle","drawSeriesPoints","drawCircle","shadow","arc","PI","decimatePoints","drawSymbolFn","drawBar","barLeft","barRight","fillStyleCallback","drawLeft","drawRight","drawTop","drawBottom","drawSeriesBars","calculatedBottom","filloptions","seriesColor","SNAPPING_CONSTANT","PANHINT_LENGTH_CONSTANT","ZOOM_DISTANCE_MARGIN","computePreferedLogTickValues","endLimit","rangeStep","log10End","log10Start","vals","power","mult","setDataminRange","processAxisOffset","map","axisName","logTickGenerator","logTickFormatter","inverted","invertedLogTransform","logTransform","invertedLogInverseTransform","logInverseTransform","invertedTransform","PREFERRED_LOG_TICK_VALUES","EXTENDED_LOG_TICK_VALUES","minIdx","maxIdx","logTickValues","clampAxis","tickValue","pixelCoord","lastDisplayed","inverseNoTicks","idx","idealPixelCoord","reverse","customAxis","formattedValue","lastZero","lastIndexOf","exp","version","logTicksGenerator","handlers","square","rect","rectangle","diamond","triangle","sin","cross","ellipse","plus","process1DRawData","flatdata","onZoomClick","zoomOut","amount","page","ec","getXAxes","getYAxes","center","zoom","onMouseWheel","isMacScroll","originalEvent","deltaY","isPanAction","onDragEnd","getOptions","preventDefault","onMouseDown","canDrag","onMouseUp","isLeftMouseButtonPressed","button","onDragStart","panAxes","prevCursor","pan","cursor","plotState","navigationState","onDrag","frameRate","smartPan","startPageX","startPageY","panTimeout","setTimeout","panHint","onDblClick","activate","getTouchedAxis","Event","detail","axisTouched","trigger","onClick","interactive","mousewheel","dblclick","click","endx","endy","startx","starty","end","dirX","Object","keys","navigationOffset","axisMin","axisMax","diagMode","w","h","xf","yf","minmax","axisZoom","plotZoom","offsetBelow","offsetAbove","preventEvent","axisPan","plotPan","navigationOffsetBelow","navigationOffsetAbove","recenter","shouldSnap","adjustDeltaToSnap","isDiagonalMode","restoreAxisOffset","initialState","prevDelta","snap","touchPointX","touchPointY","findMatchingSeries","allseries","stack","addBottomPoints","formattedPoints","stackData","needsBottom","hasBottom","other","px","py","intery","qx","qy","otherps","otherpoints","newpoints","withlines","withsteps","fromgap","keyOffset","accumulateOffset","initTouchNavigation","addEventListener","drag","pinch","doubleTap","recenterPlot","removeEventListener","presetNavigationState","gesture","gestureState","touchedAxis","getAxis","noAxisTouched","navigationConstraint","zoomEnable","prevDistance","prevTapTime","prevPanPosition","prevTapPosition","prevTouchedAxis","currentTouchedAxis","updateData","updatePrevPanPosition","wasPinchEvent","updateprevPanPosition","pinchDragTimeout","setPrevDistance","pinchDistance","zoomPlot","recenterPlotOnDoubleTap","enableTouch","checkAxesForDoubleTap","firstTouch","secondTouch","zoomAmount","getPoint","touches","pageX","pageY","axisTouch1","axisTouch2","axisDir","t1","t2","initHover","triggerCleanupEvent","tap","generatePlothoverEvent","mousemove","onMouseMove","onMouseLeave","highlights","doTriggerClickHoverEvent","eventType","searchDistance","seriesFlag","triggerClickHoverEvent","lastMouseMoveEvent","hover","unhighlight","eventname","canvasX","canvasY","auto","highlight","indexOfHighlight","hi","drawBarHighlight","drawPointHighlight","newEvent","changedTouches","pointRadius","closePath","interpretGestures","updateOnMultipleTouches","mainEventHolder","isPinchEvent","executeAction","isDoubleTap","onDoubleTap","longTap","longTapTriggerId","updatePrevForDoubleTap","prevTap","currentTap","updateCurrentForDoubleTap","updateStateForLongTapStart","tapStartTime","Date","getTime","interceptedLongTap","currentTapStart","currentTapEnd","updateStateForLongTapEnd","currentTime","intervalBetweenTaps","maxIntervalBetweenTaps","maxDistanceBetweenTaps","preventEventPropagation","allowEventPropagation","stopPropagation","noTouchActive","twoTouches","target","touchstart","touchmove","touchend","waitForLongTap","isLongTap","longTapTrigger","isTap","formatDate","fmt","monthNames","dayNames","showMilliseconds","addMilliseconds","date","ms","parts","sufix","formatLanguage","NIEmbeddedBrowser","locale","getFormatterOptions","formatString","getFormattedDateString","formatOptions","showYear","Intl","DateTimeFormat","year","month","day","formatParts","formatToParts","formatPartsTypeList","_ref","dayIndex","monthIndex","dayMonthDelimiter","dayValue","leftPad","monthValue","yearValue","padAmount","padNTimes","getFractionalSecondsString","milliseconds","forceFractionalSeconds","fractionalSecondsIndex","fractionalSecondsSearch","RegExp","fallbackDigitCount","numberOfFractionalSeconds","fractionalSecondsString","substring","getFormattedTimeString","getMilliseconds","formattedDate","hour","minute","second","lastDigitSearch","lastIndex","_ref2","hourIndex","minuteIndex","hourMinuteDelimiter","hourValue","minuteValue","showSeconds","secondValue","dayPeriod","getFormattedDateTimeString","language","browserLanguage","languages","dateString","timeString","getDefaultDateTimeString","gregorianDate","msString","time","Globalize","strftime","pad","nTimes","escape","localDateValue","getDate","timeFormatStartIndex","timeFormatEndIndex","timeFormat","dateValue","valueOf","valueOfFirstData","dateInSeconds","seconds","dateInMinutes","minutes","dateInHours","hours","days","timeEpoch","minDateValue","makeUtcWrapper","err","addProxyMethod","sourceObj","sourceMethod","targetObj","targetMethod","utc","props","dateGenerator","timezone","timezoneJS","setTimezone","setTime","updateAxisFirstData","plotData","firstPlotData","minFirstPlotData","specQuarters","specMonths","timeUnitSize","unit","setMilliseconds","setSeconds","getSeconds","setMinutes","getMinutes","setHours","getHours","setMonth","getMonth","setFullYear","getFullYear","setDate","quarter","v1000","carry","timeformat","twelveHourClock","millisecond","baseSpec","AxisLabel","axisLabel","axisLabels","axisLabelPadding","calculateSize","flotAxisName","cleanup","axisId","layerId","degrees","svgLayer","rotate","createSVGTransform","setTranslate","setRotate","calculateOffsets","offsets","white-space","selection","updateSelection","getSelection","which","body","focus","onselectstart","savedhandlers","ondrag","setSelectionPos","first","mouseUpHandler","one","selectionIsSane","triggerSelectedEvent","c1","c2","selectionDirection","p1","p2","currentMode","updateMode","clearSelection","setSelection","drawSelectionDecorations","oX","oY","earWidth","mousedown","shape","composeImages","canvasOrSvgSources","destinationCanvas","validCanvasOrSvgSources","isValidSource","allImgCompositionPromises","validCanvasOrSvgSource","tempImg","Image","Promise","getGenerateTempImg","all","then","getExecuteImgComposition","failureCallback","canvasOrSvgSource","isValidFromCanvas","isValidFromContent","tagName","getComputedStyle","visibility","sourceDescription","id","sourceComponent","successCallbackFunc","failureCallbackFunc","onload","evt","successfullyLoaded","onabort","console","onerror","generateTempImageFromCanvasOrSvg","tempImgs","copyImgsToCanvas","copyCanvasToImg","canvas","img","src","toDataURL","getCSSRules","styleSheets","rulesList","rules","cssRules","rule","cssText","embedCSSRulesInSVG","svg","classList","innerHTML","copySVGToImgMostBrowsers","source","patchSVGSource","blob","Blob","domURL","self","URL","webkitURL","url","createObjectURL","copySVGToImgSafari","utf8BinaryString","arrayBuffer","binaryString","utf8Array","Uint8Array","String","fromCharCode","subarray","TextEncoder","TextEncoderLite","encode","btoa","svgSource","copySVGToImg","adaptDestSizeToZoom","sources","containsSVGs","srcImgTagName","find","prepareImagesToBeComposed","destination","SUCCESSFULIMAGEPREPARATION","EMPTYARRAYOFIMAGESOURCES","minX","genLeft","minY","genTop","maxX","genRight","maxY","genBottom","NEGATIVEIMAGESIZE","xCompOffset","yCompOffset","prepareImagesResult","destinationCtx","drawImage","adnotateDestImgWithBoundingClientRect","srcCanvasOrSvg","destImg","GENERALFAILURECALLBACKERROR","insertLegend","legendEntries","legend","html","remove","entry","labelHtml","iconHtml","entries","maxLabelLength","xPos","yPos","svgShapeDefs","getEntryIconHtml","strokeColor","strokeWidth","legendEl","appendTo","getLegendEntries","labelFormatter","sorted","lf","ascending","checkOptions","opts1","opts2","prop","shouldRedraw","oldEntries","newEntries","newEntry","oldEntry","newOpts","oldOpts","oldPlotOffset","newPlotOffset","defaultOptions"],"mappings":"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","file":"jquery.flot.js","sourcesContent":["/** ## jquery.flot.canvaswrapper\n\nThis plugin contains the function for creating and manipulating both the canvas\nlayers and svg layers.\n\nThe Canvas object is a wrapper around an HTML5 canvas tag.\nThe constructor Canvas(cls, container) takes as parameters cls,\nthe list of classes to apply to the canvas adnd the containter,\nelement onto which to append the canvas. The canvas operations\ndon't work unless the canvas is attached to the DOM.\n\n### jquery.canvaswrapper.js API functions\n*/\n\n(function($) {\n    var Canvas = function(cls, container) {\n        var element = container.getElementsByClassName(cls)[0];\n\n        if (!element) {\n            element = document.createElement('canvas');\n            element.className = cls;\n            element.style.direction = 'ltr';\n            element.style.position = 'absolute';\n            element.style.left = '0px';\n            element.style.top = '0px';\n\n            container.appendChild(element);\n\n            // If HTML5 Canvas isn't available, throw\n\n            if (!element.getContext) {\n                throw new Error('Canvas is not available.');\n            }\n        }\n\n        this.element = element;\n\n        var context = this.context = element.getContext('2d');\n        this.pixelRatio = $.plot.browser.getPixelRatio(context);\n\n        // Size the canvas to match the internal dimensions of its container\n\n        var box = container.getBoundingClientRect();\n        this.resize(box.width, box.height);\n\n        // Collection of HTML div layers for text overlaid onto the canvas\n\n        this.SVGContainer = null;\n        this.SVG = {};\n\n        // Cache of text fragments and metrics, so we can avoid expensively\n        // re-calculating them when the plot is re-rendered in a loop.\n\n        this._textCache = {};\n    }\n\n    /**\n    - resize(width, height)\n\n     Resizes the canvas to the given dimensions.\n     The width represents the new width of the canvas, meanwhile the height\n     is the new height of the canvas, both of them in pixels.\n    */\n\n    Canvas.prototype.resize = function(width, height) {\n        var minSize = 10;\n        width = width < minSize ? minSize : width;\n        height = height < minSize ? minSize : height;\n\n        var element = this.element,\n            context = this.context,\n            pixelRatio = this.pixelRatio;\n\n        // Resize the canvas, increasing its density based on the display's\n        // pixel ratio; basically giving it more pixels without increasing the\n        // size of its element, to take advantage of the fact that retina\n        // displays have that many more pixels in the same advertised space.\n\n        // Resizing should reset the state (excanvas seems to be buggy though)\n\n        if (this.width !== width) {\n            element.width = width * pixelRatio;\n            element.style.width = width + 'px';\n            this.width = width;\n        }\n\n        if (this.height !== height) {\n            element.height = height * pixelRatio;\n            element.style.height = height + 'px';\n            this.height = height;\n        }\n\n        // Save the context, so we can reset in case we get replotted.  The\n        // restore ensure that we're really back at the initial state, and\n        // should be safe even if we haven't saved the initial state yet.\n\n        context.restore();\n        context.save();\n\n        // Scale the coordinate space to match the display density; so even though we\n        // may have twice as many pixels, we still want lines and other drawing to\n        // appear at the same size; the extra pixels will just make them crisper.\n\n        context.scale(pixelRatio, pixelRatio);\n    };\n\n    /**\n    - clear()\n\n     Clears the entire canvas area, not including any overlaid HTML text\n    */\n    Canvas.prototype.clear = function() {\n        this.context.clearRect(0, 0, this.width, this.height);\n    };\n\n    /**\n    - render()\n\n     Finishes rendering the canvas, including managing the text overlay.\n    */\n    Canvas.prototype.render = function() {\n        var cache = this._textCache;\n\n        // For each text layer, add elements marked as active that haven't\n        // already been rendered, and remove those that are no longer active.\n\n        for (var layerKey in cache) {\n            if (hasOwnProperty.call(cache, layerKey)) {\n                var layer = this.getSVGLayer(layerKey),\n                    layerCache = cache[layerKey];\n\n                var display = layer.style.display;\n                layer.style.display = 'none';\n\n                for (var styleKey in layerCache) {\n                    if (hasOwnProperty.call(layerCache, styleKey)) {\n                        var styleCache = layerCache[styleKey];\n                        for (var key in styleCache) {\n                            if (hasOwnProperty.call(styleCache, key)) {\n                                var val = styleCache[key],\n                                    positions = val.positions;\n\n                                for (var i = 0, position; positions[i]; i++) {\n                                    position = positions[i];\n                                    if (position.active) {\n                                        if (!position.rendered) {\n                                            layer.appendChild(position.element);\n                                            position.rendered = true;\n                                        }\n                                    } else {\n                                        positions.splice(i--, 1);\n                                        if (position.rendered) {\n                                            while (position.element.firstChild) {\n                                                position.element.removeChild(position.element.firstChild);\n                                            }\n                                            position.element.parentNode.removeChild(position.element);\n                                        }\n                                    }\n                                }\n\n                                if (positions.length === 0) {\n                                    if (val.measured) {\n                                        val.measured = false;\n                                    } else {\n                                        delete styleCache[key];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                layer.style.display = display;\n            }\n        }\n    };\n\n    /**\n    - getSVGLayer(classes)\n\n     Creates (if necessary) and returns the SVG overlay container.\n     The classes string represents the string of space-separated CSS classes\n     used to uniquely identify the text layer. It return the svg-layer div.\n    */\n    Canvas.prototype.getSVGLayer = function(classes) {\n        var layer = this.SVG[classes];\n\n        // Create the SVG layer if it doesn't exist\n\n        if (!layer) {\n            // Create the svg layer container, if it doesn't exist\n\n            var svgElement;\n\n            if (!this.SVGContainer) {\n                this.SVGContainer = document.createElement('div');\n                this.SVGContainer.className = 'flot-svg';\n                this.SVGContainer.style.position = 'absolute';\n                this.SVGContainer.style.top = '0px';\n                this.SVGContainer.style.left = '0px';\n                this.SVGContainer.style.bottom = '0px';\n                this.SVGContainer.style.right = '0px';\n                this.SVGContainer.style.pointerEvents = 'none';\n                this.element.parentNode.appendChild(this.SVGContainer);\n\n                svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n                svgElement.style.width = '100%';\n                svgElement.style.height = '100%';\n\n                this.SVGContainer.appendChild(svgElement);\n            } else {\n                svgElement = this.SVGContainer.firstChild;\n            }\n\n            layer = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            layer.setAttribute('class', classes);\n            layer.style.position = 'absolute';\n            layer.style.top = '0px';\n            layer.style.left = '0px';\n            layer.style.bottom = '0px';\n            layer.style.right = '0px';\n            svgElement.appendChild(layer);\n            this.SVG[classes] = layer;\n        }\n\n        return layer;\n    };\n\n    /**\n    - getTextInfo(layer, text, font, angle, width)\n\n     Creates (if necessary) and returns a text info object.\n     The object looks like this:\n     ```js\n     {\n         width //Width of the text's wrapper div.\n         height //Height of the text's wrapper div.\n         element //The HTML div containing the text.\n         positions //Array of positions at which this text is drawn.\n      }\n      ```\n      The positions array contains objects that look like this:\n      ```js\n      {\n         active //Flag indicating whether the text should be visible.\n         rendered //Flag indicating whether the text is currently visible.\n         element //The HTML div containing the text.\n         text //The actual text and is identical with element[0].textContent.\n         x //X coordinate at which to draw the text.\n         y //Y coordinate at which to draw the text.\n      }\n      ```\n      Each position after the first receives a clone of the original element.\n      The idea is that that the width, height, and general 'identity' of the\n      text is constant no matter where it is placed; the placements are a\n      secondary property.\n\n      Canvas maintains a cache of recently-used text info objects; getTextInfo\n      either returns the cached element or creates a new entry.\n\n     The layer parameter is string of space-separated CSS classes uniquely\n     identifying the layer containing this text.\n     Text is the text string to retrieve info for.\n     Font is either a string of space-separated CSS classes or a font-spec object,\n     defining the text's font and style.\n     Angle is the angle at which to rotate the text, in degrees. Angle is currently unused,\n     it will be implemented in the future.\n     The last parameter is the Maximum width of the text before it wraps.\n     The method returns a text info object.\n    */\n    Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n        var textStyle, layerCache, styleCache, info;\n\n        // Cast the value to a string, in case we were given a number or such\n\n        text = '' + text;\n\n        // If the font is a font-spec object, generate a CSS font definition\n\n        if (typeof font === 'object') {\n            textStyle = font.style + ' ' + font.variant + ' ' + font.weight + ' ' + font.size + 'px/' + font.lineHeight + 'px ' + font.family;\n        } else {\n            textStyle = font;\n        }\n\n        // Retrieve (or create) the cache for the text's layer and styles\n\n        layerCache = this._textCache[layer];\n\n        if (layerCache == null) {\n            layerCache = this._textCache[layer] = {};\n        }\n\n        styleCache = layerCache[textStyle];\n\n        if (styleCache == null) {\n            styleCache = layerCache[textStyle] = {};\n        }\n\n        var key = generateKey(text);\n        info = styleCache[key];\n\n        // If we can't find a matching element in our cache, create a new one\n\n        if (!info) {\n            var element = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n            if (text.indexOf('<br>') !== -1) {\n                addTspanElements(text, element, -9999);\n            } else {\n                var textNode = document.createTextNode(text);\n                element.appendChild(textNode);\n            }\n\n            element.style.position = 'absolute';\n            element.style.maxWidth = width;\n            element.setAttributeNS(null, 'x', -9999);\n            element.setAttributeNS(null, 'y', -9999);\n\n            if (typeof font === 'object') {\n                element.style.font = textStyle;\n                element.style.fill = font.fill;\n            } else if (typeof font === 'string') {\n                element.setAttribute('class', font);\n            }\n\n            this.getSVGLayer(layer).appendChild(element);\n            var elementRect = element.getBBox();\n\n            info = styleCache[key] = {\n                width: elementRect.width,\n                height: elementRect.height,\n                measured: true,\n                element: element,\n                positions: []\n            };\n\n            //remove elements from dom\n            while (element.firstChild) {\n                element.removeChild(element.firstChild);\n            }\n            element.parentNode.removeChild(element);\n        }\n\n        info.measured = true;\n        return info;\n    };\n\n    /**\n    - addText (layer, x, y, text, font, angle, width, halign, valign, transforms)\n\n     Adds a text string to the canvas text overlay.\n     The text isn't drawn immediately; it is marked as rendering, which will\n     result in its addition to the canvas on the next render pass.\n\n     The layer is string of space-separated CSS classes uniquely\n     identifying the layer containing this text.\n     X and Y represents the X and Y coordinate at which to draw the text.\n     and text is the string to draw\n    */\n    Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign, transforms) {\n        var info = this.getTextInfo(layer, text, font, angle, width),\n            positions = info.positions;\n\n        // Tweak the div's position to match the text's alignment\n\n        if (halign === 'center') {\n            x -= info.width / 2;\n        } else if (halign === 'right') {\n            x -= info.width;\n        }\n\n        if (valign === 'middle') {\n            y -= info.height / 2;\n        } else if (valign === 'bottom') {\n            y -= info.height;\n        }\n\n        y += 0.75 * info.height;\n\n        // Determine whether this text already exists at this position.\n        // If so, mark it for inclusion in the next render pass.\n\n        for (var i = 0, position; positions[i]; i++) {\n            position = positions[i];\n            if (position.x === x && position.y === y && position.text === text) {\n                position.active = true;\n                return;\n            } else if (position.active === false) {\n                position.active = true;\n                position.text = text;\n                if (text.indexOf('<br>') !== -1) {\n                    y -= 0.25 * info.height;\n                    addTspanElements(text, position.element, x);\n                } else {\n                    position.element.textContent = text;\n                }\n                position.element.setAttributeNS(null, 'x', x);\n                position.element.setAttributeNS(null, 'y', y);\n                position.x = x;\n                position.y = y;\n                return;\n            }\n        }\n\n        // If the text doesn't exist at this position, create a new entry\n\n        // For the very first position we'll re-use the original element,\n        // while for subsequent ones we'll clone it.\n\n        position = {\n            active: true,\n            rendered: false,\n            element: positions.length ? info.element.cloneNode() : info.element,\n            text: text,\n            x: x,\n            y: y\n        };\n\n        positions.push(position);\n\n        if (text.indexOf('<br>') !== -1) {\n            y -= 0.25 * info.height;\n            addTspanElements(text, position.element, x);\n        } else {\n            position.element.textContent = text;\n        }\n\n        // Move the element to its final position within the container\n        position.element.setAttributeNS(null, 'x', x);\n        position.element.setAttributeNS(null, 'y', y);\n        position.element.style.textAlign = halign;\n\n        if (transforms) {\n            transforms.forEach(function(t) {\n                info.element.transform.baseVal.appendItem(t);\n            });\n        }\n    };\n\n    var addTspanElements = function(text, element, x) {\n        var lines = text.split('<br>'),\n            tspan, i, offset;\n\n        for (i = 0; i < lines.length; i++) {\n            if (!element.childNodes[i]) {\n                tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                element.appendChild(tspan);\n            } else {\n                tspan = element.childNodes[i];\n            }\n            tspan.textContent = lines[i];\n            offset = i * 1 + 'em';\n            tspan.setAttributeNS(null, 'dy', offset);\n            tspan.setAttributeNS(null, 'x', x);\n        }\n    }\n\n    /**\n    - removeText (layer, x, y, text, font, angle)\n\n      The function removes one or more text strings from the canvas text overlay.\n      If no parameters are given, all text within the layer is removed.\n\n      Note that the text is not immediately removed; it is simply marked as\n      inactive, which will result in its removal on the next render pass.\n      This avoids the performance penalty for 'clear and redraw' behavior,\n      where we potentially get rid of all text on a layer, but will likely\n      add back most or all of it later, as when redrawing axes, for example.\n\n      The layer is a string of space-separated CSS classes uniquely\n      identifying the layer containing this text. The following parameter are\n      X and Y coordinate of the text.\n      Text is the string to remove, while the font is either a string of space-separated CSS\n      classes or a font-spec object, defining the text's font and style.\n     */\n    Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n        var info, htmlYCoord;\n        if (text == null) {\n            var layerCache = this._textCache[layer];\n            if (layerCache != null) {\n                for (var styleKey in layerCache) {\n                    if (hasOwnProperty.call(layerCache, styleKey)) {\n                        var styleCache = layerCache[styleKey];\n                        for (var key in styleCache) {\n                            if (hasOwnProperty.call(styleCache, key)) {\n                                var positions = styleCache[key].positions;\n                                positions.forEach(function(position) {\n                                    position.active = false;\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            info = this.getTextInfo(layer, text, font, angle);\n            positions = info.positions;\n            positions.forEach(function(position) {\n                htmlYCoord = y + 0.75 * info.height;\n                if (position.x === x && position.y === htmlYCoord && position.text === text) {\n                    position.active = false;\n                }\n            });\n        }\n    };\n\n    /**\n    - clearCache()\n\n     Clears the cache used to speed up the text size measurements.\n     As an (unfortunate) side effect all text within the text Layer is removed.\n     Use this function before plot.setupGrid() and plot.draw() if the plot just\n     became visible or the styles changed.\n    */\n    Canvas.prototype.clearCache = function() {\n        var cache = this._textCache;\n        for (var layerKey in cache) {\n            if (hasOwnProperty.call(cache, layerKey)) {\n                var layer = this.getSVGLayer(layerKey);\n                while (layer.firstChild) {\n                    layer.removeChild(layer.firstChild);\n                }\n            }\n        };\n\n        this._textCache = {};\n    };\n\n    function generateKey(text) {\n        return text.replace(/0|1|2|3|4|5|6|7|8|9/g, '0');\n    }\n\n    if (!window.Flot) {\n        window.Flot = {};\n    }\n\n    window.Flot.Canvas = Canvas;\n})(jQuery);\n","/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n\n(function($) {\n    $.color = {};\n\n    // construct color object with some convenient chainable helpers\n    $.color.make = function (r, g, b, a) {\n        var o = {};\n        o.r = r || 0;\n        o.g = g || 0;\n        o.b = b || 0;\n        o.a = a != null ? a : 1;\n\n        o.add = function (c, d) {\n            for (var i = 0; i < c.length; ++i) {\n                o[c.charAt(i)] += d;\n            }\n\n            return o.normalize();\n        };\n\n        o.scale = function (c, f) {\n            for (var i = 0; i < c.length; ++i) {\n                o[c.charAt(i)] *= f;\n            }\n\n            return o.normalize();\n        };\n\n        o.toString = function () {\n            if (o.a >= 1.0) {\n                return \"rgb(\" + [o.r, o.g, o.b].join(\",\") + \")\";\n            } else {\n                return \"rgba(\" + [o.r, o.g, o.b, o.a].join(\",\") + \")\";\n            }\n        };\n\n        o.normalize = function () {\n            function clamp(min, value, max) {\n                return value < min ? min : (value > max ? max : value);\n            }\n\n            o.r = clamp(0, parseInt(o.r), 255);\n            o.g = clamp(0, parseInt(o.g), 255);\n            o.b = clamp(0, parseInt(o.b), 255);\n            o.a = clamp(0, o.a, 1);\n            return o;\n        };\n\n        o.clone = function () {\n            return $.color.make(o.r, o.b, o.g, o.a);\n        };\n\n        return o.normalize();\n    }\n\n    // extract CSS color property from element, going up in the DOM\n    // if it's \"transparent\"\n    $.color.extract = function (elem, css) {\n        var c;\n\n        do {\n            c = elem.css(css).toLowerCase();\n            // keep going until we find an element that has color, or\n            // we hit the body or root (have no parent)\n            if (c !== '' && c !== 'transparent') {\n                break;\n            }\n\n            elem = elem.parent();\n        } while (elem.length && !$.nodeName(elem.get(0), \"body\"));\n\n        // catch Safari's way of signalling transparent\n        if (c === \"rgba(0, 0, 0, 0)\") {\n            c = \"transparent\";\n        }\n\n        return $.color.parse(c);\n    }\n\n    // parse CSS color string (like \"rgb(10, 32, 43)\" or \"#fff\"),\n    // returns color object, if parsing failed, you get black (0, 0,\n    // 0) out\n    $.color.parse = function (str) {\n        var res, m = $.color.make;\n\n        // Look for rgb(num,num,num)\n        res = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str);\n        if (res) {\n            return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));\n        }\n\n        // Look for rgba(num,num,num,num)\n        res = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)\n        if (res) {\n            return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));\n        }\n\n        // Look for rgb(num%,num%,num%)\n        res = /rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*\\)/.exec(str);\n        if (res) {\n            return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55);\n        }\n\n        // Look for rgba(num%,num%,num%,num)\n        res = /rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str);\n        if (res) {\n            return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55, parseFloat(res[4]));\n        }\n\n        // Look for #a0b1c2\n        res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str);\n        if (res) {\n            return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));\n        }\n\n        // Look for #fff\n        res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str);\n        if (res) {\n            return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2], 16), parseInt(res[3] + res[3], 16));\n        }\n\n        // Otherwise, we're most likely dealing with a named color\n        var name = $.trim(str).toLowerCase();\n        if (name === \"transparent\") {\n            return m(255, 255, 255, 0);\n        } else {\n            // default to black\n            res = lookupColors[name] || [0, 0, 0];\n            return m(res[0], res[1], res[2]);\n        }\n    }\n\n    var lookupColors = {\n        aqua: [0, 255, 255],\n        azure: [240, 255, 255],\n        beige: [245, 245, 220],\n        black: [0, 0, 0],\n        blue: [0, 0, 255],\n        brown: [165, 42, 42],\n        cyan: [0, 255, 255],\n        darkblue: [0, 0, 139],\n        darkcyan: [0, 139, 139],\n        darkgrey: [169, 169, 169],\n        darkgreen: [0, 100, 0],\n        darkkhaki: [189, 183, 107],\n        darkmagenta: [139, 0, 139],\n        darkolivegreen: [85, 107, 47],\n        darkorange: [255, 140, 0],\n        darkorchid: [153, 50, 204],\n        darkred: [139, 0, 0],\n        darksalmon: [233, 150, 122],\n        darkviolet: [148, 0, 211],\n        fuchsia: [255, 0, 255],\n        gold: [255, 215, 0],\n        green: [0, 128, 0],\n        indigo: [75, 0, 130],\n        khaki: [240, 230, 140],\n        lightblue: [173, 216, 230],\n        lightcyan: [224, 255, 255],\n        lightgreen: [144, 238, 144],\n        lightgrey: [211, 211, 211],\n        lightpink: [255, 182, 193],\n        lightyellow: [255, 255, 224],\n        lime: [0, 255, 0],\n        magenta: [255, 0, 255],\n        maroon: [128, 0, 0],\n        navy: [0, 0, 128],\n        olive: [128, 128, 0],\n        orange: [255, 165, 0],\n        pink: [255, 192, 203],\n        purple: [128, 0, 128],\n        violet: [128, 0, 128],\n        red: [255, 0, 0],\n        silver: [192, 192, 192],\n        white: [255, 255, 255],\n        yellow: [255, 255, 0]\n    };\n})(jQuery);\n","/* Javascript plotting library for jQuery, version 1.0.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// the actual Flot code\n(function($) {\n    \"use strict\";\n\n    var Canvas = window.Flot.Canvas;\n\n    function defaultTickGenerator(axis) {\n        var ticks = [],\n            start = $.plot.saturated.saturate($.plot.saturated.floorInBase(axis.min, axis.tickSize)),\n            i = 0,\n            v = Number.NaN,\n            prev;\n\n        if (start === -Number.MAX_VALUE) {\n            ticks.push(start);\n            start = $.plot.saturated.floorInBase(axis.min + axis.tickSize, axis.tickSize);\n        }\n\n        do {\n            prev = v;\n            //v = start + i * axis.tickSize;\n            v = $.plot.saturated.multiplyAdd(axis.tickSize, i, start);\n            ticks.push(v);\n            ++i;\n        } while (v < axis.max && v !== prev);\n\n        return ticks;\n    }\n\n    function defaultTickFormatter(value, axis, precision) {\n        var oldTickDecimals = axis.tickDecimals,\n            expPosition = (\"\" + value).indexOf(\"e\");\n\n        if (expPosition !== -1) {\n            return expRepTickFormatter(value, axis, precision);\n        }\n\n        if (precision > 0) {\n            axis.tickDecimals = precision;\n        }\n\n        var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1,\n            formatted = \"\" + Math.round(value * factor) / factor;\n\n        // If tickDecimals was specified, ensure that we have exactly that\n        // much precision; otherwise default to the value's own precision.\n        if (axis.tickDecimals != null) {\n            var decimal = formatted.indexOf(\".\"),\n                decimalPrecision = decimal === -1 ? 0 : formatted.length - decimal - 1;\n            if (decimalPrecision < axis.tickDecimals) {\n                var decimals = (\"\" + factor).substr(1, axis.tickDecimals - decimalPrecision);\n                formatted = (decimalPrecision ? formatted : formatted + \".\") + decimals;\n            }\n        }\n\n        axis.tickDecimals = oldTickDecimals;\n        return formatted;\n    };\n\n    function expRepTickFormatter(value, axis, precision) {\n        var expPosition = (\"\" + value).indexOf(\"e\"),\n            exponentValue = parseInt((\"\" + value).substr(expPosition + 1)),\n            tenExponent = expPosition !== -1 ? exponentValue : (value > 0 ? Math.floor(Math.log(value) / Math.LN10) : 0),\n            roundWith = Math.pow(10, tenExponent),\n            x = value / roundWith;\n\n        if (precision) {\n            var updatedPrecision = recomputePrecision(value, precision);\n            return (value / roundWith).toFixed(updatedPrecision) + 'e' + tenExponent;\n        }\n\n        if (axis.tickDecimals > 0) {\n            return x.toFixed(recomputePrecision(value, axis.tickDecimals)) + 'e' + tenExponent;\n        }\n        return x.toFixed() + 'e' + tenExponent;\n    }\n\n    function recomputePrecision(num, precision) {\n        //for numbers close to zero, the precision from flot will be a big number\n        //while for big numbers, the precision will be negative\n        var log10Value = Math.log(Math.abs(num)) * Math.LOG10E,\n            newPrecision = Math.abs(log10Value + precision);\n\n        return newPrecision <= 20 ? Math.floor(newPrecision) : 20;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // The top-level container for the entire plot.\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n        var series = [],\n            options = {\n                // the color theme used for graphs\n                colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n                xaxis: {\n                    show: null, // null = auto-detect, true = always, false = never\n                    position: \"bottom\", // or \"top\"\n                    mode: null, // null or \"time\"\n                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n                    color: null, // base color, labels, ticks\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    transform: null, // null or f: number -> number to transform axis\n                    inverseTransform: null, // if transform is set, this should be the inverse function\n                    min: null, // min. value to show, null means set automatically\n                    max: null, // max. value to show, null means set automatically\n                    autoScaleMargin: null, // margin in % to add if autoScale option is on \"loose\" mode,\n                    autoScale: \"exact\", // Available modes: \"none\", \"loose\", \"exact\", \"sliding-window\"\n                    windowSize: null, // null or number. This is the size of sliding-window.\n                    growOnly: null, // grow only, useful for smoother auto-scale, the scales will grow to accomodate data but won't shrink back.\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                    tickFormatter: null, // fn: number -> string\n                    showTickLabels: \"major\", // \"none\", \"endpoints\", \"major\", \"all\"\n                    labelWidth: null, // size of tick labels in pixels\n                    labelHeight: null,\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\n                    tickLength: null, // size in pixels of major tick marks\n                    showMinorTicks: null, // true = show minor tick marks, false = hide minor tick marks\n                    showTicks: null, // true = show tick marks, false = hide all tick marks\n                    gridLines: null, // true = show grid lines, false = hide grid lines\n                    alignTicksWithAxis: null, // axis number or null for no sync\n                    tickDecimals: null, // no. of decimals, null means auto\n                    tickSize: null, // number or [number, \"unit\"]\n                    minTickSize: null, // number or [number, \"unit\"]\n                    offset: { below: 0, above: 0 }, // the plot drawing offset. this is calculated by the flot.navigate for each axis\n                    boxPosition: { centerX: 0, centerY: 0 } //position of the axis on the corresponding axis box\n                },\n                yaxis: {\n                    autoScaleMargin: 0.02, // margin in % to add if autoScale option is on \"loose\" mode\n                    autoScale: \"loose\", // Available modes: \"none\", \"loose\", \"exact\"\n                    growOnly: null, // grow only, useful for smoother auto-scale, the scales will grow to accomodate data but won't shrink back.\n                    position: \"left\", // or \"right\"\n                    showTickLabels: \"major\", // \"none\", \"endpoints\", \"major\", \"all\"\n                    offset: { below: 0, above: 0 }, // the plot drawing offset. this is calculated by the flot.navigate for each axis\n                    boxPosition: { centerX: 0, centerY: 0 } //position of the axis on the corresponding axis box\n                },\n                xaxes: [],\n                yaxes: [],\n                series: {\n                    points: {\n                        show: false,\n                        radius: 3,\n                        lineWidth: 2, // in pixels\n                        fill: true,\n                        fillColor: \"#ffffff\",\n                        symbol: 'circle' // or callback\n                    },\n                    lines: {\n                        // we don't put in show: false so we can see\n                        // whether lines were actively disabled\n                        lineWidth: 1, // in pixels\n                        fill: false,\n                        fillColor: null,\n                        steps: false\n                        // Omit 'zero', so we can later default its value to\n                        // match that of the 'fill' option.\n                    },\n                    bars: {\n                        show: false,\n                        lineWidth: 2, // in pixels\n                        // barWidth: number or [number, absolute]\n                        // when 'absolute' is false, 'number' is relative to the minimum distance between points for the series\n                        // when 'absolute' is true, 'number' is considered to be in units of the x-axis\n                        horizontal: false,\n                        barWidth: 0.8,\n                        fill: true,\n                        fillColor: null,\n                        align: \"left\", // \"left\", \"right\", or \"center\"\n                        zero: true\n                    },\n                    shadowSize: 3,\n                    highlightColor: null\n                },\n                grid: {\n                    show: true,\n                    aboveData: false,\n                    color: \"#545454\", // primary color used for outline and labels\n                    backgroundColor: null, // null for transparent, else color\n                    borderColor: null, // set if different from the grid color\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    margin: 0, // distance from the canvas edge to the grid\n                    labelMargin: 5, // in pixels\n                    axisMargin: 8, // in pixels\n                    borderWidth: 1, // in pixels\n                    minBorderMargin: null, // in pixels, null means taken from points radius\n                    markings: null, // array of ranges or fn: axes -> array of ranges\n                    markingsColor: \"#f4f4f4\",\n                    markingsLineWidth: 2,\n                    // interactive stuff\n                    clickable: false,\n                    hoverable: false,\n                    autoHighlight: true, // highlight in case mouse is near\n                    mouseActiveRadius: 15 // how far the mouse can be away to activate an item\n                },\n                interaction: {\n                    redrawOverlayInterval: 1000 / 60 // time between updates, -1 means in same flow\n                },\n                hooks: {}\n            },\n            surface = null, // the canvas for the plot itself\n            overlay = null, // canvas for interactive stuff on top of plot\n            eventHolder = null, // jQuery object that events should be bound to\n            ctx = null,\n            octx = null,\n            xaxes = [],\n            yaxes = [],\n            plotOffset = {\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            },\n            plotWidth = 0,\n            plotHeight = 0,\n            hooks = {\n                processOptions: [],\n                processRawData: [],\n                processDatapoints: [],\n                processOffset: [],\n                setupGrid: [],\n                adjustSeriesDataRange: [],\n                setRange: [],\n                drawBackground: [],\n                drawSeries: [],\n                drawAxis: [],\n                draw: [],\n                axisReserveSpace: [],\n                bindEvents: [],\n                drawOverlay: [],\n                resize: [],\n                shutdown: []\n            },\n            plot = this;\n\n        var eventManager = {};\n\n        // interactive features\n\n        var redrawTimeout = null;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function() {\n            return placeholder;\n        };\n        plot.getCanvas = function() {\n            return surface.element;\n        };\n        plot.getSurface = function() {\n            return surface;\n        };\n        plot.getEventHolder = function() {\n            return eventHolder[0];\n        };\n        plot.getPlotOffset = function() {\n            return plotOffset;\n        };\n        plot.width = function() {\n            return plotWidth;\n        };\n        plot.height = function() {\n            return plotHeight;\n        };\n        plot.offset = function() {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function() {\n            return series;\n        };\n        plot.getAxes = function() {\n            var res = {};\n            $.each(xaxes.concat(yaxes), function(_, axis) {\n                if (axis) {\n                    res[axis.direction + (axis.n !== 1 ? axis.n : \"\") + \"axis\"] = axis;\n                }\n            });\n            return res;\n        };\n        plot.getXAxes = function() {\n            return xaxes;\n        };\n        plot.getYAxes = function() {\n            return yaxes;\n        };\n        plot.c2p = canvasToCartesianAxisCoords;\n        plot.p2c = cartesianAxisToCanvasCoords;\n        plot.getOptions = function() {\n            return options;\n        };\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function(point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.destroy = function() {\n            shutdown();\n            placeholder.removeData(\"plot\").empty();\n\n            series = [];\n            options = null;\n            surface = null;\n            overlay = null;\n            eventHolder = null;\n            ctx = null;\n            octx = null;\n            xaxes = [];\n            yaxes = [];\n            hooks = null;\n            plot = null;\n        };\n\n        plot.resize = function() {\n            var width = placeholder.width(),\n                height = placeholder.height();\n            surface.resize(width, height);\n            overlay.resize(width, height);\n\n            executeHooks(hooks.resize, [width, height]);\n        };\n\n        plot.clearTextCache = function () {\n            surface.clearCache();\n            overlay.clearCache();\n        };\n\n        plot.autoScaleAxis = autoScaleAxis;\n        plot.computeRangeForDataSeries = computeRangeForDataSeries;\n        plot.adjustSeriesDataRange = adjustSeriesDataRange;\n        plot.findNearbyItem = findNearbyItem;\n        plot.findNearbyInterpolationPoint = findNearbyInterpolationPoint;\n        plot.computeValuePrecision = computeValuePrecision;\n        plot.computeTickSize = computeTickSize;\n        plot.addEventHandler = addEventHandler;\n\n        // public attributes\n        plot.hooks = hooks;\n\n        // initialize\n        var MINOR_TICKS_COUNT_CONSTANT = $.plot.uiConstants.MINOR_TICKS_COUNT_CONSTANT;\n        var TICK_LENGTH_CONSTANT = $.plot.uiConstants.TICK_LENGTH_CONSTANT;\n        initPlugins(plot);\n        setupCanvases();\n        parseOptions(options_);\n        setData(data_);\n        setupGrid();\n        draw();\n        bindEvents();\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i) {\n                hook[i].apply(this, args);\n            }\n        }\n\n        function initPlugins() {\n            // References to key classes, allowing plugins to modify them\n\n            var classes = {\n                Canvas: Canvas\n            };\n\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot, classes);\n                if (p.options) {\n                    $.extend(true, options, p.options);\n                }\n            }\n        }\n\n        function parseOptions(opts) {\n            $.extend(true, options, opts);\n\n            // $.extend merges arrays, rather than replacing them.  When less\n            // colors are provided than the size of the default palette, we\n            // end up with those colors plus the remaining defaults, which is\n            // not expected behavior; avoid it by replacing them here.\n\n            if (opts && opts.colors) {\n                options.colors = opts.colors;\n            }\n\n            if (options.xaxis.color == null) {\n                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            }\n\n            if (options.yaxis.color == null) {\n                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            }\n\n            if (options.xaxis.tickColor == null) {\n                // grid.tickColor for back-compatibility\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n            }\n\n            if (options.yaxis.tickColor == null) {\n                // grid.tickColor for back-compatibility\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n            }\n\n            if (options.grid.borderColor == null) {\n                options.grid.borderColor = options.grid.color;\n            }\n\n            if (options.grid.tickColor == null) {\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            }\n\n            // Fill in defaults for axis options, including any unspecified\n            // font-spec fields, if a font-spec was provided.\n\n            // If no x/y axis options were provided, create one of each anyway,\n            // since the rest of the code assumes that they exist.\n\n            var i, axisOptions, axisCount,\n                fontSize = placeholder.css(\"font-size\"),\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n                fontDefaults = {\n                    style: placeholder.css(\"font-style\"),\n                    size: Math.round(0.8 * fontSizeDefault),\n                    variant: placeholder.css(\"font-variant\"),\n                    weight: placeholder.css(\"font-weight\"),\n                    family: placeholder.css(\"font-family\")\n                };\n\n            axisCount = options.xaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n                axisOptions = options.xaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n                options.xaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            axisCount = options.yaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n                axisOptions = options.yaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n                options.yaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i) {\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            }\n\n            for (i = 0; i < options.yaxes.length; ++i) {\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n            }\n\n            //process boxPosition options used for axis.box size\n            $.each(allAxes(), function(_, axis) {\n                axis.boxPosition = axis.options.boxPosition || {centerX: 0, centerY: 0};\n            });\n\n            // add hooks from options\n            for (var n in hooks) {\n                if (options.hooks[n] && options.hooks[n].length) {\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\n                }\n            }\n\n            executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            var oldseries = series;\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData(oldseries);\n        }\n\n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                } else {\n                    s.data = d[i];\n                }\n\n                res.push(s);\n            }\n\n            return res;\n        }\n\n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if (typeof a === \"object\") {\n                // if we got a real axis, extract number\n                a = a.n;\n            }\n\n            if (typeof a !== \"number\") {\n                a = 1; // default to first axis\n            }\n\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return xaxes.concat(yaxes).filter(function(a) {\n                return a;\n            });\n        }\n\n        // canvas to axis for cartesian axes\n        function canvasToCartesianAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes\n            var res = {},\n                i, axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\n                }\n            }\n\n            if (res.x1 !== undefined) {\n                res.x = res.x1;\n            }\n\n            if (res.y1 !== undefined) {\n                res.y = res.y1;\n            }\n\n            return res;\n        }\n\n        // axis to canvas for cartesian axes\n        function cartesianAxisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {},\n                i, axis, key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n === 1) {\n                        key = \"x\";\n                    }\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n === 1) {\n                        key = \"y\";\n                    }\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1]) {\n                axes[number - 1] = {\n                    n: number, // save the number for future reference\n                    direction: axes === xaxes ? \"x\" : \"y\",\n                    options: $.extend(true, {}, axes === xaxes ? options.xaxis : options.yaxis)\n                };\n            }\n\n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n            var neededColors = series.length,\n                maxIndex = -1,\n                i;\n\n            // Subtract the number of series that already have fixed colors or\n            // color indexes from the number that we still need to generate.\n\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    neededColors--;\n                    if (typeof sc === \"number\" && sc > maxIndex) {\n                        maxIndex = sc;\n                    }\n                }\n            }\n\n            // If any of the series have fixed color indexes, then we need to\n            // generate at least as many colors as the highest index.\n\n            if (neededColors <= maxIndex) {\n                neededColors = maxIndex + 1;\n            }\n\n            // Generate all the colors, using first the option colors and then\n            // variations on those colors once they're exhausted.\n\n            var c, colors = [],\n                colorPool = options.colors,\n                colorPoolSize = colorPool.length,\n                variation = 0,\n                definedColors = Math.max(0, series.length - neededColors);\n\n            for (i = 0; i < neededColors; i++) {\n                c = $.color.parse(colorPool[(definedColors + i) % colorPoolSize] || \"#666\");\n\n                // Each time we exhaust the colors in the pool we adjust\n                // a scaling factor used to produce more variations on\n                // those colors. The factor alternates negative/positive\n                // to produce lighter/darker colors.\n\n                // Reset the variation after every few cycles, or else\n                // it will end up producing only white or black colors.\n\n                if (i % colorPoolSize === 0 && i) {\n                    if (variation >= 0) {\n                        if (variation < 0.5) {\n                            variation = -variation - 0.2;\n                        } else variation = 0;\n                    } else variation = -variation;\n                }\n\n                colors[i] = c.scale('rgb', 1 + variation);\n            }\n\n            // Finalize the series options, filling in their colors\n\n            var colori = 0,\n                s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                } else if (typeof s.color === \"number\") {\n                    s.color = colors[s.color].toString();\n                }\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v, show = true;\n                    for (v in s) {\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    }\n\n                    if (show) {\n                        s.lines.show = true;\n                    }\n                }\n\n                // If nothing was provided for lines.zero, default it to match\n                // lines.fill, since areas by default should extend to zero.\n\n                if (s.lines.zero == null) {\n                    s.lines.zero = !!s.lines.fill;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n\n        function processData(prevSeries) {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                i, j, k, m,\n                s, points, ps, val, f, p,\n                data, format;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min !== -Infinity) {\n                    axis.datamin = min;\n                }\n\n                if (max > axis.datamax && max !== Infinity) {\n                    axis.datamax = max;\n                }\n            }\n\n            function reusePoints(prevSeries, i) {\n                if (prevSeries && prevSeries[i] && prevSeries[i].datapoints && prevSeries[i].datapoints.points) {\n                    return prevSeries[i].datapoints.points;\n                }\n\n                return [];\n            }\n\n            $.each(allAxes(), function(_, axis) {\n                // init axis\n                if (axis.options.growOnly !== true) {\n                    axis.datamin = topSentry;\n                    axis.datamax = bottomSentry;\n                } else {\n                    if (axis.datamin === undefined) {\n                        axis.datamin = topSentry;\n                    }\n                    if (axis.datamax === undefined) {\n                        axis.datamax = bottomSentry;\n                    }\n                }\n                axis.used = false;\n            });\n\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = {\n                    points: []\n                };\n\n                if (s.datapoints.points.length === 0) {\n                    s.datapoints.points = reusePoints(prevSeries, i);\n                }\n\n                executeHooks(hooks.processRawData, [s, s.data, s.datapoints]);\n            }\n\n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                data = s.data;\n                format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({\n                        x: true,\n                        y: false,\n                        number: true,\n                        required: true,\n                        computeRange: s.xaxis.options.autoScale !== 'none',\n                        defaultValue: null\n                    });\n\n                    format.push({\n                        x: false,\n                        y: true,\n                        number: true,\n                        required: true,\n                        computeRange: s.yaxis.options.autoScale !== 'none',\n                        defaultValue: null\n                    });\n\n                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\n                        var expectedPs = s.datapoints.pointsize != null ? s.datapoints.pointsize : (s.data && s.data[0] && s.data[0].length ? s.data[0].length : 3);\n                        if (expectedPs > 2) {\n                            format.push({\n                                x: false,\n                                y: true,\n                                number: true,\n                                required: false,\n                                computeRange: s.yaxis.options.autoScale !== 'none',\n                                defaultValue: 0\n                            });\n                        }\n                    }\n\n                    s.datapoints.format = format;\n                }\n\n                s.xaxis.used = s.yaxis.used = true;\n\n                if (s.datapoints.pointsize != null) continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                var insertSteps = s.lines.show && s.lines.steps;\n\n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val)) {\n                                        val = null;\n                                    }\n                                }\n\n                                if (val == null) {\n                                    if (f.required) nullify = true;\n\n                                    if (f.defaultValue != null) val = f.defaultValue;\n                                }\n                            }\n\n                            points[k + m] = val;\n                        }\n                    }\n\n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.computeRange) {\n                                    if (f.x) {\n                                        updateAxis(s.xaxis, val, val);\n                                    }\n                                    if (f.y) {\n                                        updateAxis(s.yaxis, val, val);\n                                    }\n                                }\n                            }\n                            points[k + m] = null;\n                        }\n                    } else {\n                        // a little bit of line specific stuff that\n                        // perhaps shouldn't be here, but lacking\n                        // better means...\n                        if (insertSteps && k > 0 &&\n                            points[k - ps] != null &&\n                            points[k - ps] !== points[k] &&\n                            points[k - ps + 1] !== points[k + 1]) {\n                            // copy the point to make room for a middle point\n                            for (m = 0; m < ps; ++m) {\n                                points[k + ps + m] = points[k + m];\n                            }\n\n                            // middle point has same y\n                            points[k + 1] = points[k - ps + 1];\n\n                            // we've added a point, better reflect that\n                            k += ps;\n                        }\n                    }\n                }\n\n                points.length = k; //trims the internal buffer to the correct length\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                executeHooks(hooks.processDatapoints, [s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                format = s.datapoints.format;\n\n                if (format.every(function (f) { return !f.computeRange; })) {\n                    continue;\n                }\n\n                var range = plot.adjustSeriesDataRange(s,\n                    plot.computeRangeForDataSeries(s));\n\n                executeHooks(hooks.adjustSeriesDataRange, [s, range]);\n\n                updateAxis(s.xaxis, range.xmin, range.xmax);\n                updateAxis(s.yaxis, range.ymin, range.ymax);\n            }\n\n            $.each(allAxes(), function(_, axis) {\n                if (axis.datamin === topSentry) {\n                    axis.datamin = null;\n                }\n\n                if (axis.datamax === bottomSentry) {\n                    axis.datamax = null;\n                }\n            });\n        }\n\n        function setupCanvases() {\n            // Make sure the placeholder is clear of everything except canvases\n            // from a previous plot in this container that we'll try to re-use.\n\n            placeholder.css(\"padding\", 0) // padding messes up the positioning\n                .children().filter(function() {\n                    return !$(this).hasClass(\"flot-overlay\") && !$(this).hasClass('flot-base');\n                }).remove();\n\n            if (placeholder.css(\"position\") === 'static') {\n                placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n            }\n\n            surface = new Canvas(\"flot-base\", placeholder[0]);\n            overlay = new Canvas(\"flot-overlay\", placeholder[0]); // overlay canvas for interactive features\n\n            ctx = surface.context;\n            octx = overlay.context;\n\n            // define which element we're listening for events on\n            eventHolder = $(overlay.element).unbind();\n\n            // If we're re-using a plot object, shut down the old one\n\n            var existing = placeholder.data(\"plot\");\n\n            if (existing) {\n                existing.shutdown();\n                overlay.clear();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function addEventHandler(event, handler, eventHolder, priority) {\n            var key = eventHolder + event;\n            var eventList = eventManager[key] || [];\n\n            eventList.push({\"event\": event, \"handler\": handler, \"eventHolder\": eventHolder, \"priority\": priority});\n            eventList.sort((a, b) => b.priority - a.priority );\n            eventList.forEach( eventData => {\n                eventData.eventHolder.unbind(eventData.event, eventData.handler);\n                eventData.eventHolder.bind(eventData.event, eventData.handler);\n            });\n\n            eventManager[key] = eventList;\n        }\n\n        function shutdown() {\n            if (redrawTimeout) {\n                clearTimeout(redrawTimeout);\n            }\n\n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n\n            function identity(x) {\n                return x;\n            }\n\n            var s, m, t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n\n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction === \"x\") {\n                if (isFinite(t(axis.max) - t(axis.min))) {\n                    s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                } else {\n                    s = axis.scale = 1 / Math.abs($.plot.saturated.delta(t(axis.min), t(axis.max), plotWidth));\n                }\n                m = Math.min(t(axis.max), t(axis.min));\n            } else {\n                if (isFinite(t(axis.max) - t(axis.min))) {\n                    s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                } else {\n                    s = axis.scale = 1 / Math.abs($.plot.saturated.delta(t(axis.min), t(axis.max), plotHeight));\n                }\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t === identity) {\n                // slight optimization\n                axis.p2c = function(p) {\n                    if (isFinite(p - m)) {\n                        return (p - m) * s;\n                    } else {\n                        return (p / 4 - m / 4) * s * 4;\n                    }\n                };\n            } else {\n                axis.p2c = function(p) {\n                    var tp = t(p);\n\n                    if (isFinite(tp - m)) {\n                        return (tp - m) * s;\n                    } else {\n                        return (tp / 4 - m / 4) * s * 4;\n                    }\n                };\n            }\n\n            // canvas coordinate to data point\n            if (!it) {\n                axis.c2p = function(c) {\n                    return m + c / s;\n                };\n            } else {\n                axis.c2p = function(c) {\n                    return it(m + c / s);\n                };\n            }\n        }\n\n        function measureTickLabels(axis) {\n            var opts = axis.options,\n                ticks = opts.showTickLabels !== 'none' && axis.ticks ? axis.ticks : [],\n                showMajorTickLabels = opts.showTickLabels === 'major' || opts.showTickLabels === 'all',\n                showEndpointsTickLabels = opts.showTickLabels === 'endpoints' || opts.showTickLabels === 'all',\n                labelWidth = opts.labelWidth || 0,\n                labelHeight = opts.labelHeight || 0,\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                font = opts.font || \"flot-tick-label tickLabel\";\n\n            for (var i = 0; i < ticks.length; ++i) {\n                var t = ticks[i];\n                var label = t.label;\n\n                if (!t.label ||\n                    (showMajorTickLabels === false && i > 0 && i < ticks.length - 1) ||\n                    (showEndpointsTickLabels === false && (i === 0 || i === ticks.length - 1))) {\n                    continue;\n                }\n\n                if (typeof t.label === 'object') {\n                    label = t.label.name;\n                }\n\n                var info = surface.getTextInfo(layer, label, font);\n\n                labelWidth = Math.max(labelWidth, info.width);\n                labelHeight = Math.max(labelHeight, info.height);\n            }\n\n            axis.labelWidth = opts.labelWidth || labelWidth;\n            axis.labelHeight = opts.labelHeight || labelHeight;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset; this first phase only looks at one\n            // dimension per axis, the other dimension depends on the\n            // other axes so will have to wait\n\n            // here reserve additional space\n            executeHooks(hooks.axisReserveSpace, [axis]);\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                isXAxis = axis.direction === \"x\",\n                tickLength = axis.options.tickLength,\n                showTicks = axis.options.showTicks,\n                showMinorTicks = axis.options.showMinorTicks,\n                gridLines = axis.options.gridLines,\n                axisMargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                innermost = true,\n                outermost = true,\n                found = false;\n\n            // Determine the axis's position in its direction and on its side\n\n            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\n                if (a && (a.show || a.reserveSpace)) {\n                    if (a === axis) {\n                        found = true;\n                    } else if (a.options.position === pos) {\n                        if (found) {\n                            outermost = false;\n                        } else {\n                            innermost = false;\n                        }\n                    }\n                }\n            });\n\n            // The outermost axis on each side has no margin\n            if (outermost) {\n                axisMargin = 0;\n            }\n\n            // Set the default tickLength if necessary\n            if (tickLength == null) {\n                tickLength = TICK_LENGTH_CONSTANT;\n            }\n\n            // By default, major tick marks are visible\n            if (showTicks == null) {\n                showTicks = true;\n            }\n\n            // By default, minor tick marks are visible\n            if (showMinorTicks == null) {\n                showMinorTicks = true;\n            }\n\n            // By default, grid lines are visible\n            if (gridLines == null) {\n                if (innermost) {\n                    gridLines = true;\n                } else {\n                    gridLines = false;\n                }\n            }\n\n            if (!isNaN(+tickLength)) {\n                padding += showTicks ? +tickLength : 0;\n            }\n\n            if (isXAxis) {\n                lh += padding;\n\n                if (pos === \"bottom\") {\n                    plotOffset.bottom += lh + axisMargin;\n                    axis.box = {\n                        top: surface.height - plotOffset.bottom,\n                        height: lh\n                    };\n                } else {\n                    axis.box = {\n                        top: plotOffset.top + axisMargin,\n                        height: lh\n                    };\n                    plotOffset.top += lh + axisMargin;\n                }\n            } else {\n                lw += padding;\n\n                if (pos === \"left\") {\n                    axis.box = {\n                        left: plotOffset.left + axisMargin,\n                        width: lw\n                    };\n                    plotOffset.left += lw + axisMargin;\n                } else {\n                    plotOffset.right += lw + axisMargin;\n                    axis.box = {\n                        left: surface.width - plotOffset.right,\n                        width: lw\n                    };\n                }\n            }\n\n            // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.showMinorTicks = showMinorTicks;\n            axis.showTicks = showTicks;\n            axis.gridLines = gridLines;\n            axis.box.padding = padding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // now that all axis boxes have been placed in one\n            // dimension, we can set the remaining dimension coordinates\n            if (axis.direction === \"x\") {\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n            } else {\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n            }\n        }\n\n        function adjustLayoutForThingsStickingOut() {\n            // possibly adjust plot offset to ensure everything stays\n            // inside the canvas and isn't clipped off\n\n            var minMargin = options.grid.minBorderMargin,\n                i;\n\n            // check stuff from the plot (FIXME: this should just read\n            // a value from the series, otherwise it's impossible to\n            // customize)\n            if (minMargin == null) {\n                minMargin = 0;\n                for (i = 0; i < series.length; ++i) {\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2));\n                }\n            }\n\n            var a, offset = {},\n                margins = {\n                    left: minMargin,\n                    right: minMargin,\n                    top: minMargin,\n                    bottom: minMargin\n                };\n\n            // check axis labels, note we don't check the actual\n            // labels but instead use the overall width/height to not\n            // jump as much around with replots\n            $.each(allAxes(), function(_, axis) {\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n                    if (axis.direction === \"x\") {\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\n                    } else {\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\n                    }\n                }\n            });\n\n            for (a in margins) {\n                offset[a] = margins[a] - plotOffset[a];\n            }\n            $.each(xaxes.concat(yaxes), function(_, axis) {\n                alignAxisWithGrid(axis, offset, function (offset) {\n                    return offset > 0;\n                });\n            });\n\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n        }\n\n        function alignAxisWithGrid(axis, offset, isValid) {\n            if (axis.direction === \"x\") {\n                if (axis.position === \"bottom\" && isValid(offset.bottom)) {\n                    axis.box.top -= Math.ceil(offset.bottom);\n                }\n                if (axis.position === \"top\" && isValid(offset.top)) {\n                    axis.box.top += Math.ceil(offset.top);\n                }\n            } else {\n                if (axis.position === \"left\" && isValid(offset.left)) {\n                    axis.box.left += Math.ceil(offset.left);\n                }\n                if (axis.position === \"right\" && isValid(offset.right)) {\n                    axis.box.left -= Math.ceil(offset.right);\n                }\n            }\n        }\n\n        function setupGrid() {\n            var i, a, axes = allAxes(),\n                showGrid = options.grid.show;\n\n            // Initialize the plot's offset from the edge of the canvas\n\n            for (a in plotOffset) {\n                plotOffset[a] = 0;\n            }\n\n            executeHooks(hooks.processOffset, [plotOffset]);\n\n            // If the grid is visible, add its border width to the offset\n            for (a in plotOffset) {\n                if (typeof (options.grid.borderWidth) === \"object\") {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n                } else {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n                }\n            }\n\n            $.each(axes, function(_, axis) {\n                var axisOpts = axis.options;\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n                setupTickFormatter(axis);\n                executeHooks(hooks.setRange, [axis]);\n                setRange(axis);\n            });\n\n            if (showGrid) {\n                plotWidth = surface.width - plotOffset.left - plotOffset.right;\n                plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n                var allocatedAxes = $.grep(axes, function(axis) {\n                    return axis.show || axis.reserveSpace;\n                });\n\n                $.each(allocatedAxes, function(_, axis) {\n                    // make the ticks\n                    setupTickGeneration(axis);\n                    setMajorTicks(axis);\n                    snapRangeToTicks(axis, axis.ticks);\n\n                    //for computing the endpoints precision, transformationHelpers are needed\n                    setTransformationHelpers(axis);\n                    setEndpointTicks(axis, series);\n\n                    // find labelWidth/Height for axis\n                    measureTickLabels(axis);\n                });\n\n                // with all dimensions calculated, we can compute the\n                // axis bounding boxes, start from the outside\n                // (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i) {\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n                }\n\n                // make sure we've got enough space for things that\n                // might stick out\n                adjustLayoutForThingsStickingOut();\n\n                $.each(allocatedAxes, function(_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n            }\n\n            //adjust axis and plotOffset according to grid.margins\n            if (options.grid.margin) {\n                for (a in plotOffset) {\n                    var margin = options.grid.margin || 0;\n                    plotOffset[a] += typeof margin === \"number\" ? margin : (margin[a] || 0);\n                }\n                $.each(xaxes.concat(yaxes), function(_, axis) {\n                    alignAxisWithGrid(axis, options.grid.margin, function(offset) {\n                        return offset !== undefined && offset !== null;\n                    });\n                });\n            }\n\n            //after adjusting the axis, plot width and height will be modified\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plot dimensions, we can compute the scaling\n            $.each(axes, function(_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (showGrid) {\n                drawAxisLabels();\n            }\n\n            executeHooks(hooks.setupGrid, []);\n        }\n\n        function widenMinMax(minimum, maximum) {\n            var min = (minimum === undefined ? null : minimum);\n            var max = (maximum === undefined ? null : maximum);\n            var delta = max - min;\n            if (delta === 0.0) {\n                // degenerate case\n                var widen = max === 0 ? 1 : 0.01;\n                var wmin = null;\n                if (min == null) {\n                    wmin -= widen;\n                }\n\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (max == null || min != null) {\n                    max += widen;\n                }\n\n                if (wmin != null) {\n                    min = wmin;\n                }\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        }\n\n        function autoScaleAxis(axis) {\n            var opts = axis.options,\n                min = opts.min,\n                max = opts.max,\n                datamin = axis.datamin,\n                datamax = axis.datamax,\n                delta;\n\n            switch (opts.autoScale) {\n                case \"none\":\n                    min = +(opts.min != null ? opts.min : datamin);\n                    max = +(opts.max != null ? opts.max : datamax);\n                    break;\n                case \"loose\":\n                    if (datamin != null && datamax != null) {\n                        min = datamin;\n                        max = datamax;\n                        delta = $.plot.saturated.saturate(max - min);\n                        var margin = ((typeof opts.autoScaleMargin === 'number') ? opts.autoScaleMargin : 0.02);\n                        min = $.plot.saturated.saturate(min - delta * margin);\n                        max = $.plot.saturated.saturate(max + delta * margin);\n\n                        // make sure we don't go below zero if all values are positive\n                        if (min < 0 && datamin >= 0) {\n                            min = 0;\n                        }\n                    } else {\n                        min = opts.min;\n                        max = opts.max;\n                    }\n                    break;\n                case \"exact\":\n                    min = (datamin != null ? datamin : opts.min);\n                    max = (datamax != null ? datamax : opts.max);\n                    break;\n                case \"sliding-window\":\n                    if (datamax > max) {\n                        // move the window to fit the new data,\n                        // keeping the axis range constant\n                        max = datamax;\n                        min = Math.max(datamax - (opts.windowSize || 100), min);\n                    }\n                    break;\n            }\n\n            var widenedMinMax = widenMinMax(min, max);\n            min = widenedMinMax.min;\n            max = widenedMinMax.max;\n\n            // grow loose or grow exact supported\n            if (opts.growOnly === true && opts.autoScale !== \"none\" && opts.autoScale !== \"sliding-window\") {\n                min = (min < datamin) ? min : (datamin !== null ? datamin : min);\n                max = (max > datamax) ? max : (datamax !== null ? datamax : max);\n            }\n\n            axis.autoScaledMin = min;\n            axis.autoScaledMax = max;\n        }\n\n        function setRange(axis) {\n            autoScaleAxis(axis);\n\n            var min = axis.autoScaledMin,\n                max = axis.autoScaledMax,\n                plotOffset = axis.options.offset;\n\n            min = (min != null ? min : -1) + (plotOffset.below || 0);\n            max = (max != null ? max : 1) + (plotOffset.above || 0);\n\n            if (min > max) {\n                var tmp = min;\n                min = max;\n                max = tmp;\n                axis.options.offset = { above: 0, below: 0 };\n            }\n\n            axis.min = $.plot.saturated.saturate(min);\n            axis.max = $.plot.saturated.saturate(max);\n        }\n\n        function computeValuePrecision (min, max, direction, ticks, tickDecimals) {\n            var noTicks = fixupNumberOfTicks(direction, surface, ticks);\n\n            var delta = $.plot.saturated.delta(min, max, noTicks),\n                dec = -Math.floor(Math.log(delta) / Math.LN10);\n\n            //if it is called with tickDecimals, then the precision should not be greather then that\n            if (tickDecimals && dec > tickDecimals) {\n                dec = tickDecimals;\n            }\n\n            var magn = Math.pow(10, -dec),\n                norm = delta / magn;\n\n            if (norm > 2.25 && norm < 3 && (dec + 1) <= tickDecimals) {\n                //we need an extra decimals when tickSize is 2.5\n                ++dec;\n            }\n\n            return isFinite(dec) ? dec : 0;\n        };\n\n        function computeTickSize (min, max, noTicks, tickDecimals) {\n            var delta = $.plot.saturated.delta(min, max, noTicks),\n                dec = -Math.floor(Math.log(delta) / Math.LN10);\n\n            //if it is called with tickDecimals, then the precision should not be greather then that\n            if (tickDecimals && dec > tickDecimals) {\n                dec = tickDecimals;\n            }\n\n            var magn = Math.pow(10, -dec),\n                norm = delta / magn, // norm is between 1.0 and 10.0\n                size;\n\n            if (norm < 1.5) {\n                size = 1;\n            } else if (norm < 3) {\n                size = 2;\n                if (norm > 2.25 && (tickDecimals == null || (dec + 1) <= tickDecimals)) {\n                    size = 2.5;\n                }\n            } else if (norm < 7.5) {\n                size = 5;\n            } else {\n                size = 10;\n            }\n\n            size *= magn;\n            return size;\n        }\n\n        function getAxisTickSize(min, max, direction, options, tickDecimals) {\n            var noTicks;\n\n            if (typeof options.ticks === \"number\" && options.ticks > 0) {\n                noTicks = options.ticks;\n            } else {\n            // heuristic based on the model a*sqrt(x) fitted to\n            // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(direction === \"x\" ? surface.width : surface.height);\n            }\n\n            var size = computeTickSize(min, max, noTicks, tickDecimals);\n\n            if (options.minTickSize != null && size < options.minTickSize) {\n                size = options.minTickSize;\n            }\n\n            return options.tickSize || size;\n        };\n\n        function fixupNumberOfTicks(direction, surface, ticksOption) {\n            var noTicks;\n\n            if (typeof ticksOption === \"number\" && ticksOption > 0) {\n                noTicks = ticksOption;\n            } else {\n                noTicks = 0.3 * Math.sqrt(direction === \"x\" ? surface.width : surface.height);\n            }\n\n            return noTicks;\n        }\n\n        function setupTickFormatter(axis) {\n            var opts = axis.options;\n            if (!axis.tickFormatter) {\n                if (typeof opts.tickFormatter === 'function') {\n                    axis.tickFormatter = function() {\n                        var args = Array.prototype.slice.call(arguments);\n                        return \"\" + opts.tickFormatter.apply(null, args);\n                    };\n                } else {\n                    axis.tickFormatter = defaultTickFormatter;\n                }\n            }\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n            var noTicks;\n\n            noTicks = fixupNumberOfTicks(axis.direction, surface, opts.ticks);\n\n            axis.delta = $.plot.saturated.delta(axis.min, axis.max, noTicks);\n            var precision = plot.computeValuePrecision(axis.min, axis.max, axis.direction, noTicks, opts.tickDecimals);\n\n            axis.tickDecimals = Math.max(0, opts.tickDecimals != null ? opts.tickDecimals : precision);\n            axis.tickSize = getAxisTickSize(axis.min, axis.max, axis.direction, opts, opts.tickDecimals);\n\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n            // like flot.time.js.\n\n            if (!axis.tickGenerator) {\n                axis.tickGenerator = defaultTickGenerator;\n            }\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction === \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis !== axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = axis.tickGenerator(axis);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null) {\n                            axis.min = Math.min(axis.min, niceTicks[0]);\n                        }\n\n                        if (opts.max == null && niceTicks.length > 1) {\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                        }\n                    }\n\n                    axis.tickGenerator = function(axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [],\n                            v, i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n\n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (!axis.mode && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                            ts = axis.tickGenerator(axis);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec)))) {\n                            axis.tickDecimals = extraDec;\n                        }\n                    }\n                }\n            }\n        }\n\n        function setMajorTicks(axis) {\n            var oticks = axis.options.ticks,\n                ticks = [];\n            if (oticks == null || (typeof oticks === \"number\" && oticks > 0)) {\n                ticks = axis.tickGenerator(axis);\n            } else if (oticks) {\n                if ($.isFunction(oticks)) {\n                // generate the ticks\n                    ticks = oticks(axis);\n                } else {\n                    ticks = oticks;\n                }\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if (typeof t === \"object\") {\n                    v = +t[0];\n                    if (t.length > 1) {\n                        label = t[1];\n                    }\n                } else {\n                    v = +t;\n                }\n\n                if (!isNaN(v)) {\n                    axis.ticks.push(\n                        newTick(v, label, axis, 'major'));\n                }\n            }\n        }\n\n        function newTick(v, label, axis, type) {\n            if (!label) {\n                switch (type) {\n                    case 'min':\n                    case 'max':\n                        //improving the precision of endpoints\n                        var precision = getEndpointPrecision(v, axis);\n                        label = isFinite(precision) ? axis.tickFormatter(v, axis, precision, plot) : axis.tickFormatter(v, axis, precision, plot);\n                        break;\n                    case 'major':\n                        label = axis.tickFormatter(v, axis, undefined, plot);\n                }\n            }\n            return {\n                v: v,\n                label: label\n            };\n        }\n\n        function snapRangeToTicks(axis, ticks) {\n            if (axis.options.autoScale === \"loose\" && ticks.length > 0) {\n                // snap to ticks\n                axis.min = Math.min(axis.min, ticks[0].v);\n                axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n            }\n        }\n\n        function getEndpointPrecision(value, axis) {\n            var canvas1 = Math.floor(axis.p2c(value)),\n                canvas2 = axis.direction === \"x\" ? canvas1 + 1 : canvas1 - 1,\n                point1 = axis.c2p(canvas1),\n                point2 = axis.c2p(canvas2),\n                precision = computeValuePrecision(point1, point2, axis.direction, 1);\n\n            return precision;\n        }\n\n        function setEndpointTicks(axis, series) {\n            if (isValidEndpointTick(axis, series)) {\n                axis.ticks.unshift(newTick(axis.min, null, axis, 'min'));\n                axis.ticks.push(newTick(axis.max, null, axis, 'max'));\n            }\n        }\n\n        function isValidEndpointTick(axis, series) {\n            if (axis.options.showTickLabels === 'endpoints') {\n                return true;\n            }\n            if (axis.options.showTickLabels === 'all') {\n                var associatedSeries = series.filter(function(s) {\n                        return s.xaxis === axis;\n                    }),\n                    notAllBarSeries = associatedSeries.some(function(s) {\n                        return !s.bars.show;\n                    });\n                return associatedSeries.length === 0 || notAllBarSeries;\n            }\n            if (axis.options.showTickLabels === 'major' || axis.options.showTickLabels === 'none') {\n                return false;\n            }\n        }\n\n        function draw() {\n            surface.clear();\n            executeHooks(hooks.drawBackground, [ctx]);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor) {\n                drawBackground();\n            }\n\n            if (grid.show && !grid.aboveData) {\n                drawGrid();\n            }\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i], i, getColorOrGradient]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n\n            if (grid.show && grid.aboveData) {\n                drawGrid();\n            }\n\n            surface.render();\n\n            // A draw implies that either the axes or data have changed, so we\n            // should probably update the overlay highlights as well.\n            triggerRedrawOverlay();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = allAxes();\n\n            for (var i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction === coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n === 1) {\n                        // support x1axis as xaxis\n                        key = coord + \"axis\";\n                    }\n\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord === \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return {\n                from: from,\n                to: to,\n                axis: axis\n            };\n        }\n\n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawMarkings() {\n            // draw markings\n            var markings = options.grid.markings,\n                axes;\n\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n\n                    markings = markings(axes);\n                }\n\n                var i;\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null) {\n                        xrange.from = xrange.axis.min;\n                    }\n\n                    if (xrange.to == null) {\n                        xrange.to = xrange.axis.max;\n                    }\n\n                    if (yrange.from == null) {\n                        yrange.from = yrange.axis.min;\n                    }\n\n                    if (yrange.to == null) {\n                        yrange.to = yrange.axis.max;\n                    }\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max) {\n                        continue;\n                    }\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    var xequal = xrange.from === xrange.to,\n                        yequal = yrange.from === yrange.to;\n\n                    if (xequal && yequal) {\n                        continue;\n                    }\n\n                    // then draw\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n                    if (xequal || yequal) {\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = lineWidth;\n                        if (xequal) {\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\n                        } else {\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);\n                        }\n                        ctx.stroke();\n                    } else {\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to,\n                            xrange.to - xrange.from,\n                            yrange.from - yrange.to);\n                    }\n                }\n            }\n        }\n\n        function findEdges(axis) {\n            var box = axis.box,\n                x = 0,\n                y = 0;\n\n            // find the edges\n            if (axis.direction === \"x\") {\n                x = 0;\n                y = box.top - plotOffset.top + (axis.position === \"top\" ? box.height : 0);\n            } else {\n                y = 0;\n                x = box.left - plotOffset.left + (axis.position === \"left\" ? box.width : 0) + axis.boxPosition.centerX;\n            }\n\n            return {\n                x: x,\n                y: y\n            };\n        };\n\n        function alignPosition(lineWidth, pos) {\n            return ((lineWidth % 2) !== 0) ? Math.floor(pos) + 0.5 : pos;\n        };\n\n        function drawTickBar(axis) {\n            ctx.lineWidth = 1;\n            var edges = findEdges(axis),\n                x = edges.x,\n                y = edges.y;\n\n            // draw tick bar\n            if (axis.show) {\n                var xoff = 0,\n                    yoff = 0;\n\n                ctx.strokeStyle = axis.options.color;\n                ctx.beginPath();\n                if (axis.direction === \"x\") {\n                    xoff = plotWidth + 1;\n                } else {\n                    yoff = plotHeight + 1;\n                }\n\n                if (axis.direction === \"x\") {\n                    y = alignPosition(ctx.lineWidth, y);\n                } else {\n                    x = alignPosition(ctx.lineWidth, x);\n                }\n\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + xoff, y + yoff);\n                ctx.stroke();\n            }\n        };\n\n        function drawTickMarks(axis) {\n            var t = axis.tickLength,\n                minorTicks = axis.showMinorTicks,\n                minorTicksNr = MINOR_TICKS_COUNT_CONSTANT,\n                edges = findEdges(axis),\n                x = edges.x,\n                y = edges.y,\n                i = 0;\n\n            // draw major tick marks\n            ctx.strokeStyle = axis.options.color;\n            ctx.beginPath();\n\n            for (i = 0; i < axis.ticks.length; ++i) {\n                var v = axis.ticks[i].v,\n                    xoff = 0,\n                    yoff = 0,\n                    xminor = 0,\n                    yminor = 0,\n                    j;\n\n                if (!isNaN(v) && v >= axis.min && v <= axis.max) {\n                    if (axis.direction === \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t;\n\n                        if (axis.position === \"top\") {\n                            yoff = -yoff;\n                        }\n                    } else {\n                        y = axis.p2c(v);\n                        xoff = t;\n\n                        if (axis.position === \"left\") {\n                            xoff = -xoff;\n                        }\n                    }\n\n                    if (axis.direction === \"x\") {\n                        x = alignPosition(ctx.lineWidth, x);\n                    } else {\n                        y = alignPosition(ctx.lineWidth, y);\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n\n                //draw minor tick marks\n                if (minorTicks === true && i < axis.ticks.length - 1) {\n                    var v1 = axis.ticks[i].v,\n                        v2 = axis.ticks[i + 1].v,\n                        step = (v2 - v1) / (minorTicksNr + 1);\n\n                    for (j = 1; j <= minorTicksNr; j++) {\n                        // compute minor tick position\n                        if (axis.direction === \"x\") {\n                            yminor = t / 2; // minor ticks are half length\n                            x = alignPosition(ctx.lineWidth, axis.p2c(v1 + j * step))\n\n                            if (axis.position === \"top\") {\n                                yminor = -yminor;\n                            }\n\n                            // don't go over the plot borders\n                            if ((x < 0) || (x > plotWidth)) {\n                                continue;\n                            }\n                        } else {\n                            xminor = t / 2; // minor ticks are half length\n                            y = alignPosition(ctx.lineWidth, axis.p2c(v1 + j * step));\n\n                            if (axis.position === \"left\") {\n                                xminor = -xminor;\n                            }\n\n                            // don't go over the plot borders\n                            if ((y < 0) || (y > plotHeight)) {\n                                continue;\n                            }\n                        }\n\n                        ctx.moveTo(x, y);\n                        ctx.lineTo(x + xminor, y + yminor);\n                    }\n                }\n            }\n\n            ctx.stroke();\n        };\n\n        function drawGridLines(axis) {\n            // check if the line will be overlapped with a border\n            var overlappedWithBorder = function (value) {\n                var bw = options.grid.borderWidth;\n                return (((typeof bw === \"object\" && bw[axis.position] > 0) || bw > 0) && (value === axis.min || value === axis.max));\n            };\n\n            ctx.strokeStyle = options.grid.tickColor;\n            ctx.beginPath();\n            var i;\n            for (i = 0; i < axis.ticks.length; ++i) {\n                var v = axis.ticks[i].v,\n                    xoff = 0,\n                    yoff = 0,\n                    x = 0,\n                    y = 0;\n\n                if (isNaN(v) || v < axis.min || v > axis.max) continue;\n\n                // skip those lying on the axes if we got a border\n                if (overlappedWithBorder(v)) continue;\n\n                if (axis.direction === \"x\") {\n                    x = axis.p2c(v);\n                    y = plotHeight;\n                    yoff = -plotHeight;\n                } else {\n                    x = 0;\n                    y = axis.p2c(v);\n                    xoff = plotWidth;\n                }\n\n                if (axis.direction === \"x\") {\n                    x = alignPosition(ctx.lineWidth, x);\n                } else {\n                    y = alignPosition(ctx.lineWidth, y);\n                }\n\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + xoff, y + yoff);\n            }\n\n            ctx.stroke();\n        };\n\n        function drawBorder() {\n            // If either borderWidth or borderColor is an object, then draw the border\n            // line by line instead of as one rectangle\n            var bw = options.grid.borderWidth,\n                bc = options.grid.borderColor;\n\n            if (typeof bw === \"object\" || typeof bc === \"object\") {\n                if (typeof bw !== \"object\") {\n                    bw = {\n                        top: bw,\n                        right: bw,\n                        bottom: bw,\n                        left: bw\n                    };\n                }\n                if (typeof bc !== \"object\") {\n                    bc = {\n                        top: bc,\n                        right: bc,\n                        bottom: bc,\n                        left: bc\n                    };\n                }\n\n                if (bw.top > 0) {\n                    ctx.strokeStyle = bc.top;\n                    ctx.lineWidth = bw.top;\n                    ctx.beginPath();\n                    ctx.moveTo(0 - bw.left, 0 - bw.top / 2);\n                    ctx.lineTo(plotWidth, 0 - bw.top / 2);\n                    ctx.stroke();\n                }\n\n                if (bw.right > 0) {\n                    ctx.strokeStyle = bc.right;\n                    ctx.lineWidth = bw.right;\n                    ctx.beginPath();\n                    ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n                    ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n                    ctx.stroke();\n                }\n\n                if (bw.bottom > 0) {\n                    ctx.strokeStyle = bc.bottom;\n                    ctx.lineWidth = bw.bottom;\n                    ctx.beginPath();\n                    ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n                    ctx.lineTo(0, plotHeight + bw.bottom / 2);\n                    ctx.stroke();\n                }\n\n                if (bw.left > 0) {\n                    ctx.strokeStyle = bc.left;\n                    ctx.lineWidth = bw.left;\n                    ctx.beginPath();\n                    ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);\n                    ctx.lineTo(0 - bw.left / 2, 0);\n                    ctx.stroke();\n                }\n            } else {\n                ctx.lineWidth = bw;\n                ctx.strokeStyle = options.grid.borderColor;\n                ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw);\n            }\n        };\n\n        function drawGrid() {\n            var axes, bw;\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            drawMarkings();\n\n            axes = allAxes();\n            bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j];\n\n                if (!axis.show) {\n                    continue;\n                }\n\n                drawTickBar(axis);\n                if (axis.showTicks === true) {\n                    drawTickMarks(axis);\n                }\n\n                if (axis.gridLines === true) {\n                    drawGridLines(axis, bw);\n                }\n            }\n\n            // draw border\n            if (bw) {\n                drawBorder();\n            }\n\n            ctx.restore();\n        }\n\n        function drawAxisLabels() {\n            $.each(allAxes(), function(_, axis) {\n                var box = axis.box,\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\n                    i, x, y, halign, valign, info,\n                    margin = 3,\n                    nullBox = {x: NaN, y: NaN, width: NaN, height: NaN}, newLabelBox, labelBoxes = [],\n                    overlapping = function(x11, y11, x12, y12, x21, y21, x22, y22) {\n                        return ((x11 <= x21 && x21 <= x12) || (x21 <= x11 && x11 <= x22)) &&\n                               ((y11 <= y21 && y21 <= y12) || (y21 <= y11 && y11 <= y22));\n                    },\n                    overlapsOtherLabels = function(newLabelBox, previousLabelBoxes) {\n                        return previousLabelBoxes.some(function(labelBox) {\n                            return overlapping(\n                                newLabelBox.x, newLabelBox.y, newLabelBox.x + newLabelBox.width, newLabelBox.y + newLabelBox.height,\n                                labelBox.x, labelBox.y, labelBox.x + labelBox.width, labelBox.y + labelBox.height);\n                        });\n                    },\n                    drawAxisLabel = function (tick, labelBoxes) {\n                        if (!tick || !tick.label || tick.v < axis.min || tick.v > axis.max) {\n                            return nullBox;\n                        }\n\n                        info = surface.getTextInfo(layer, tick.label, font);\n\n                        if (axis.direction === \"x\") {\n                            halign = \"center\";\n                            x = plotOffset.left + axis.p2c(tick.v);\n                            if (axis.position === \"bottom\") {\n                                y = box.top + box.padding - axis.boxPosition.centerY;\n                            } else {\n                                y = box.top + box.height - box.padding + axis.boxPosition.centerY;\n                                valign = \"bottom\";\n                            }\n                            newLabelBox = {x: x - info.width / 2 - margin, y: y - margin, width: info.width + 2 * margin, height: info.height + 2 * margin};\n                        } else {\n                            valign = \"middle\";\n                            y = plotOffset.top + axis.p2c(tick.v);\n                            if (axis.position === \"left\") {\n                                x = box.left + box.width - box.padding - axis.boxPosition.centerX;\n                                halign = \"right\";\n                            } else {\n                                x = box.left + box.padding + axis.boxPosition.centerX;\n                            }\n                            newLabelBox = {x: x - info.width / 2 - margin, y: y - margin, width: info.width + 2 * margin, height: info.height + 2 * margin};\n                        }\n\n                        if (overlapsOtherLabels(newLabelBox, labelBoxes)) {\n                            return nullBox;\n                        }\n\n                        surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n\n                        return newLabelBox;\n                    };\n\n                // Remove text before checking for axis.show and ticks.length;\n                // otherwise plugins, like flot-tickrotor, that draw their own\n                // tick labels will end up with both theirs and the defaults.\n\n                surface.removeText(layer);\n\n                executeHooks(hooks.drawAxis, [axis, surface]);\n\n                if (!axis.show) {\n                    return;\n                }\n\n                switch (axis.options.showTickLabels) {\n                    case 'none':\n                        break;\n                    case 'endpoints':\n                        labelBoxes.push(drawAxisLabel(axis.ticks[0], labelBoxes));\n                        labelBoxes.push(drawAxisLabel(axis.ticks[axis.ticks.length - 1], labelBoxes));\n                        break;\n                    case 'major':\n                        labelBoxes.push(drawAxisLabel(axis.ticks[0], labelBoxes));\n                        labelBoxes.push(drawAxisLabel(axis.ticks[axis.ticks.length - 1], labelBoxes));\n                        for (i = 1; i < axis.ticks.length - 1; ++i) {\n                            labelBoxes.push(drawAxisLabel(axis.ticks[i], labelBoxes));\n                        }\n                        break;\n                    case 'all':\n                        labelBoxes.push(drawAxisLabel(axis.ticks[0], []));\n                        labelBoxes.push(drawAxisLabel(axis.ticks[axis.ticks.length - 1], labelBoxes));\n                        for (i = 1; i < axis.ticks.length - 1; ++i) {\n                            labelBoxes.push(drawAxisLabel(axis.ticks[i], labelBoxes));\n                        }\n                        break;\n                }\n            });\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show) {\n                $.plot.drawSeries.drawSeriesLines(series, ctx, plotOffset, plotWidth, plotHeight, plot.drawSymbol, getColorOrGradient);\n            }\n\n            if (series.bars.show) {\n                $.plot.drawSeries.drawSeriesBars(series, ctx, plotOffset, plotWidth, plotHeight, plot.drawSymbol, getColorOrGradient);\n            }\n\n            if (series.points.show) {\n                $.plot.drawSeries.drawSeriesPoints(series, ctx, plotOffset, plotWidth, plotHeight, plot.drawSymbol, getColorOrGradient);\n            }\n        }\n\n        function computeRangeForDataSeries(series, force, isValid) {\n            var points = series.datapoints.points,\n                ps = series.datapoints.pointsize,\n                format = series.datapoints.format,\n                topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                range = {\n                    xmin: topSentry,\n                    ymin: topSentry,\n                    xmax: bottomSentry,\n                    ymax: bottomSentry\n                };\n\n            for (var j = 0; j < points.length; j += ps) {\n                if (points[j] === null) {\n                    continue;\n                }\n\n                if (typeof (isValid) === 'function' && !isValid(points[j])) {\n                    continue;\n                }\n\n                for (var m = 0; m < ps; ++m) {\n                    var val = points[j + m],\n                        f = format[m];\n                    if (f === null || f === undefined) {\n                        continue;\n                    }\n\n                    if (typeof (isValid) === 'function' && !isValid(val)) {\n                        continue;\n                    }\n\n                    if ((!force && !f.computeRange) || val === Infinity || val === -Infinity) {\n                        continue;\n                    }\n\n                    if (f.x === true) {\n                        if (val < range.xmin) {\n                            range.xmin = val;\n                        }\n\n                        if (val > range.xmax) {\n                            range.xmax = val;\n                        }\n                    }\n\n                    if (f.y === true) {\n                        if (val < range.ymin) {\n                            range.ymin = val;\n                        }\n\n                        if (val > range.ymax) {\n                            range.ymax = val;\n                        }\n                    }\n                }\n            }\n\n            return range;\n        };\n\n        function adjustSeriesDataRange(series, range) {\n            if (series.bars.show) {\n                // make sure we got room for the bar on the dancing floor\n                var delta;\n\n                // update bar width if needed\n                var useAbsoluteBarWidth = series.bars.barWidth[1];\n                if (series.datapoints && series.datapoints.points && !useAbsoluteBarWidth) {\n                    computeBarWidth(series);\n                }\n\n                var barWidth = series.bars.barWidth[0] || series.bars.barWidth;\n                switch (series.bars.align) {\n                    case \"left\":\n                        delta = 0;\n                        break;\n                    case \"right\":\n                        delta = -barWidth;\n                        break;\n                    default:\n                        delta = -barWidth / 2;\n                }\n\n                if (series.bars.horizontal) {\n                    range.ymin += delta;\n                    range.ymax += delta + barWidth;\n                }\n                else {\n                    range.xmin += delta;\n                    range.xmax += delta + barWidth;\n                }\n            }\n\n            if ((series.bars.show && series.bars.zero) || (series.lines.show && series.lines.zero)) {\n                var ps = series.datapoints.pointsize;\n\n                // make sure the 0 point is included in the computed y range when requested\n                if (ps <= 2) {\n                    /*if ps > 0 the points were already taken into account for autoScale */\n                    range.ymin = Math.min(0, range.ymin);\n                    range.ymax = Math.max(0, range.ymax);\n                }\n            }\n\n            return range;\n        };\n\n        function computeBarWidth(series) {\n            var pointsize = series.datapoints.pointsize, minDistance = Number.MAX_VALUE,\n                distance = series.datapoints.points[pointsize] - series.datapoints.points[0] || 1;\n\n            if (isFinite(distance)) {\n                minDistance = distance;\n            }\n            for (var j = pointsize; j < series.datapoints.points.length - pointsize; j += pointsize) {\n                distance = Math.abs(series.datapoints.points[pointsize + j] - series.datapoints.points[j]);\n                if (distance < minDistance && isFinite(distance)) {\n                    minDistance = distance;\n                }\n            }\n\n            if (typeof series.bars.barWidth === \"number\") {\n                series.bars.barWidth = series.bars.barWidth * minDistance;\n            } else {\n                series.bars.barWidth[0] = series.bars.barWidth[0] * minDistance;\n            }\n        }\n\n        // returns the data item the mouse is over/ the cursor is closest to, or null if none is found\n        function findNearbyItem(mouseX, mouseY, seriesFilter, radius, computeDistance) {\n            var maxDistance = radius,\n                smallestDistance = maxDistance * maxDistance + 1,\n                item = null,\n                dx, dy, dist,\n                i, j, ps;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(i)) continue;\n\n                var s = series[i];\n                if (!s.datapoints) return;\n                var x, y,\n                    axisx = s.xaxis,\n                    axisy = s.yaxis,\n                    points = s.datapoints.points,\n                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\n                    my = axisy.c2p(mouseY),\n                    maxx = maxDistance / axisx.scale,\n                    maxy = maxDistance / axisy.scale;\n\n                ps = s.datapoints.pointsize;\n                // with inverse transforms, we can't use the maxx/maxy\n                // optimization, sadly\n                if (axisx.options.inverseTransform) {\n                    maxx = Number.MAX_VALUE;\n                }\n\n                if (axisy.options.inverseTransform) {\n                    maxy = Number.MAX_VALUE;\n                }\n\n                for (j = 0; j < points.length; j += ps) {\n                    x = points[j];\n                    y = points[j + 1];\n                    if (x == null) {\n                        continue;\n                    }\n\n                    if (x - mx > maxx || x - mx < -maxx ||\n                        y - my > maxy || y - my < -maxy) {\n                        continue;\n                    }\n\n                    // We have to calculate distances in pixels, not in\n                    // data units, because the scales of the axes may be different\n                    dx = Math.abs(axisx.p2c(x) - mouseX);\n                    dy = Math.abs(axisy.p2c(y) - mouseY);\n                    dist = computeDistance ? computeDistance(dx, dy) : dx * dx + dy * dy;\n\n                    // use <= to ensure last point takes precedence\n                    // (last generally means on top of)\n                    if (dist < smallestDistance) {\n                        smallestDistance = dist;\n                        item = [i, j / ps];\n                    }\n                }\n            }\n\n            if (item) {\n                i = item[0];\n                j = item[1];\n                ps = series[i].datapoints.pointsize;\n\n                return {\n                    datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n                    dataIndex: j,\n                    series: series[i],\n                    seriesIndex: i\n                };\n            }\n\n            return null;\n        }\n\n        function findNearbyInterpolationPoint(posX, posY, seriesFilter) {\n            var i, j, dist, dx, dy, ps,\n                item,\n                smallestDistance = Number.MAX_VALUE;\n\n            for (i = 0; i < series.length; ++i) {\n                if (!seriesFilter(i)) {\n                    continue;\n                }\n                var points = series[i].datapoints.points;\n                ps = series[i].datapoints.pointsize;\n\n                // if the data is coming from positive -> negative, reverse the comparison\n                const comparer = points[points.length - ps] < points[0]\n                    ? function (x1, x2) { return x1 > x2 }\n                    : function (x1, x2) { return x2 > x1 };\n\n                // do not interpolate outside the bounds of the data.\n                if (comparer(posX, points[0])) {\n                    continue;\n                }\n\n                // Find the nearest points, x-wise\n                for (j = ps; j < points.length; j += ps) {\n                    if (comparer(posX, points[j])) {\n                        break;\n                    }\n                }\n\n                // Now Interpolate\n                var y,\n                    p1x = points[j - ps],\n                    p1y = points[j - ps + 1],\n                    p2x = points[j],\n                    p2y = points[j + 1];\n\n                if ((p1x === undefined) || (p2x === undefined) ||\n                    (p1y === undefined) || (p2y === undefined)) {\n                    continue;\n                }\n\n                if (p1x === p2x) {\n                    y = p2y\n                } else {\n                    y = p1y + (p2y - p1y) * (posX - p1x) / (p2x - p1x);\n                }\n\n                posY = y;\n\n                dx = Math.abs(series[i].xaxis.p2c(p2x) - posX);\n                dy = Math.abs(series[i].yaxis.p2c(p2y) - posY);\n                dist = dx * dx + dy * dy;\n\n                if (dist < smallestDistance) {\n                    smallestDistance = dist;\n                    item = [posX, posY, i, j];\n                }\n            }\n\n            if (item) {\n                i = item[2];\n                j = item[3];\n                ps = series[i].datapoints.pointsize;\n                points = series[i].datapoints.points;\n                p1x = points[j - ps];\n                p1y = points[j - ps + 1];\n                p2x = points[j];\n                p2y = points[j + 1];\n\n                return {\n                    datapoint: [item[0], item[1]],\n                    leftPoint: [p1x, p1y],\n                    rightPoint: [p2x, p2y],\n                    seriesIndex: i\n                };\n            }\n\n            return null;\n        }\n\n        function triggerRedrawOverlay() {\n            var t = options.interaction.redrawOverlayInterval;\n            if (t === -1) { // skip event queue\n                drawOverlay();\n                return;\n            }\n\n            if (!redrawTimeout) {\n                redrawTimeout = setTimeout(function() {\n                    drawOverlay(plot);\n                }, t);\n            }\n        }\n\n        function drawOverlay(plot) {\n            redrawTimeout = null;\n\n            if (!octx) {\n                return;\n            }\n            overlay.clear();\n            executeHooks(hooks.drawOverlay, [octx, overlay]);\n            var event = new CustomEvent('onDrawingDone');\n            plot.getEventHolder().dispatchEvent(event);\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec === \"string\") {\n                return spec;\n            } else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c !== \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null) {\n                            co = co.scale('rgb', c.brightness);\n                        }\n\n                        if (c.opacity != null) {\n                            co.a *= c.opacity;\n                        }\n\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n\n                return gradient;\n            }\n        }\n    }\n\n    // Add the plot function to the top level of the jQuery object\n\n    $.plot = function(placeholder, data, options) {\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        return plot;\n    };\n\n    $.plot.version = \"1.0.3\";\n\n    $.plot.plugins = [];\n\n    // Also add the plot function as a chainable property\n    $.fn.plot = function(data, options) {\n        return this.each(function() {\n            $.plot(this, data, options);\n        });\n    };\n\n    $.plot.linearTickGenerator = defaultTickGenerator;\n    $.plot.defaultTickFormatter = defaultTickFormatter;\n    $.plot.expRepTickFormatter = expRepTickFormatter;\n})(jQuery);\n","(function ($) {\n    'use strict';\n    var saturated = {\n        saturate: function (a) {\n            if (a === Infinity) {\n                return Number.MAX_VALUE;\n            }\n\n            if (a === -Infinity) {\n                return -Number.MAX_VALUE;\n            }\n\n            return a;\n        },\n        delta: function(min, max, noTicks) {\n            return ((max - min) / noTicks) === Infinity ? (max / noTicks - min / noTicks) : (max - min) / noTicks\n        },\n        multiply: function (a, b) {\n            return saturated.saturate(a * b);\n        },\n        // returns c * bInt * a. Beahves properly in the case where c is negative\n        // and bInt * a is bigger that Number.MAX_VALUE (Infinity)\n        multiplyAdd: function (a, bInt, c) {\n            if (isFinite(a * bInt)) {\n                return saturated.saturate(a * bInt + c);\n            } else {\n                var result = c;\n\n                for (var i = 0; i < bInt; i++) {\n                    result += a;\n                }\n\n                return saturated.saturate(result);\n            }\n        },\n        // round to nearby lower multiple of base\n        floorInBase: function(n, base) {\n            return base * Math.floor(n / base);\n        }\n    };\n\n    $.plot.saturated = saturated;\n})(jQuery);\n","/** ## jquery.flot.browser.js\n\nThis plugin is used to make available some browser-related utility functions.\n\n### Methods\n*/\n\n(function ($) {\n    'use strict';\n\n    var browser = {\n        /**\n        - getPageXY(e)\n\n         Calculates the pageX and pageY using the screenX, screenY properties of the event\n         and the scrolling of the page. This is needed because the pageX and pageY\n         properties of the event are not correct while running tests in Edge. */\n        getPageXY: function (e) {\n            // This code is inspired from https://stackoverflow.com/a/3464890\n            var doc = document.documentElement,\n                pageX = e.clientX + (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0),\n                pageY = e.clientY + (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n            return { X: pageX, Y: pageY };\n        },\n\n        /**\n        - getPixelRatio(context)\n\n         This function returns the current pixel ratio defined by the product of desktop\n         zoom and page zoom.\n         Additional info: https://www.html5rocks.com/en/tutorials/canvas/hidpi/\n        */\n        getPixelRatio: function(context) {\n            var devicePixelRatio = window.devicePixelRatio || 1,\n                backingStoreRatio =\n                context.webkitBackingStorePixelRatio ||\n                context.mozBackingStorePixelRatio ||\n                context.msBackingStorePixelRatio ||\n                context.oBackingStorePixelRatio ||\n                context.backingStorePixelRatio || 1;\n            return devicePixelRatio / backingStoreRatio;\n        },\n\n        /**\n        - isSafari, isMobileSafari, isOpera, isFirefox, isIE, isEdge, isChrome, isBlink\n\n         This is a collection of functions, used to check if the code is running in a\n         particular browser or Javascript engine.\n        */\n        isSafari: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            // Safari 3.0+ \"[object HTMLElementConstructor]\"\n            return /constructor/i.test(window.top.HTMLElement) || (function (p) { return p.toString() === \"[object SafariRemoteNotification]\"; })(!window.top['safari'] || (typeof window.top.safari !== 'undefined' && window.top.safari.pushNotification));\n        },\n\n        isMobileSafari: function() {\n            //isMobileSafari adapted from https://stackoverflow.com/questions/3007480/determine-if-user-navigated-from-mobile-safari\n            return navigator.userAgent.match(/(iPod|iPhone|iPad)/) && navigator.userAgent.match(/AppleWebKit/);\n        },\n\n        isOpera: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            //Opera 8.0+\n            return (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n        },\n\n        isFirefox: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            // Firefox 1.0+\n            return typeof InstallTrigger !== 'undefined';\n        },\n\n        isIE: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            // Internet Explorer 6-11\n            return /*@cc_on!@*/false || !!document.documentMode;\n        },\n\n        isEdge: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            // Edge 20+\n            return !browser.isIE() && !!window.StyleMedia;\n        },\n\n        isChrome: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            // Chrome 1+\n            return !!window.chrome && !!window.chrome.webstore;\n        },\n\n        isBlink: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            return (browser.isChrome() || browser.isOpera()) && !!window.CSS;\n        }\n    };\n\n    $.plot.browser = browser;\n})(jQuery);\n","/**\n## jquery.flot.drawSeries.js\n\nThis plugin is used by flot for drawing lines, plots, bars or area.\n\n### Public methods\n*/\n\n(function($) {\n    \"use strict\";\n\n    function DrawSeries() {\n        function plotLine(datapoints, xoffset, yoffset, axisx, axisy, ctx) {\n            var points = datapoints.points,\n                ps = datapoints.pointsize,\n                prevx = null,\n                prevy = null;\n            var x1 = 0.0,\n                y1 = 0.0,\n                x2 = 0.0,\n                y2 = 0.0,\n                i = 0;\n\n            ctx.beginPath();\n            for (i = ps; i < points.length; i += ps) {\n                x1 = points[i - ps];\n                y1 = points[i - ps + 1];\n                x2 = points[i];\n                y2 = points[i + 1];\n\n                if (x1 === null || x2 === null) {\n                    continue;\n                }\n\n                // clip with ymin\n                if (y1 <= y2 && y1 < axisy.min) {\n                    if (y2 < axisy.min) {\n                        // line segment is outside\n                        continue;\n                    }\n                    // compute new intersection point\n                    x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y1 = axisy.min;\n                } else if (y2 <= y1 && y2 < axisy.min) {\n                    if (y1 < axisy.min) {\n                        continue;\n                    }\n\n                    x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y2 = axisy.min;\n                }\n\n                // clip with ymax\n                if (y1 >= y2 && y1 > axisy.max) {\n                    if (y2 > axisy.max) {\n                        continue;\n                    }\n\n                    x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y1 = axisy.max;\n                } else if (y2 >= y1 && y2 > axisy.max) {\n                    if (y1 > axisy.max) {\n                        continue;\n                    }\n\n                    x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y2 = axisy.max;\n                }\n\n                // clip with xmin\n                if (x1 <= x2 && x1 < axisx.min) {\n                    if (x2 < axisx.min) {\n                        continue;\n                    }\n\n                    y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x1 = axisx.min;\n                } else if (x2 <= x1 && x2 < axisx.min) {\n                    if (x1 < axisx.min) {\n                        continue;\n                    }\n\n                    y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x2 = axisx.min;\n                }\n\n                // clip with xmax\n                if (x1 >= x2 && x1 > axisx.max) {\n                    if (x2 > axisx.max) {\n                        continue;\n                    }\n\n                    y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x1 = axisx.max;\n                } else if (x2 >= x1 && x2 > axisx.max) {\n                    if (x1 > axisx.max) {\n                        continue;\n                    }\n\n                    y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x2 = axisx.max;\n                }\n\n                if (x1 !== prevx || y1 !== prevy) {\n                    ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n                }\n\n                prevx = x2;\n                prevy = y2;\n                ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n            }\n            ctx.stroke();\n        }\n\n        function plotLineArea(datapoints, axisx, axisy, fillTowards, ctx) {\n            var points = datapoints.points,\n                ps = datapoints.pointsize,\n                bottom = fillTowards > axisy.min ? Math.min(axisy.max, fillTowards) : axisy.min,\n                i = 0,\n                ypos = 1,\n                areaOpen = false,\n                segmentStart = 0,\n                segmentEnd = 0;\n\n            // we process each segment in two turns, first forward\n            // direction to sketch out top, then once we hit the\n            // end we go backwards to sketch the bottom\n            while (true) {\n                if (ps > 0 && i > points.length + ps) {\n                    break;\n                }\n\n                i += ps; // ps is negative if going backwards\n\n                var x1 = points[i - ps],\n                    y1 = points[i - ps + ypos],\n                    x2 = points[i],\n                    y2 = points[i + ypos];\n\n                if (ps === -2) {\n                    /* going backwards and no value for the bottom provided in the series*/\n                    y1 = y2 = bottom;\n                }\n\n                if (areaOpen) {\n                    if (ps > 0 && x1 != null && x2 == null) {\n                        // at turning point\n                        segmentEnd = i;\n                        ps = -ps;\n                        ypos = 2;\n                        continue;\n                    }\n\n                    if (ps < 0 && i === segmentStart + ps) {\n                        // done with the reverse sweep\n                        ctx.fill();\n                        areaOpen = false;\n                        ps = -ps;\n                        i = segmentStart = segmentEnd + ps;\n                        continue;\n                    }\n                }\n\n                if (x1 == null || x2 == null) {\n                    continue;\n                }\n\n                // clip x values\n\n                // clip with xmin\n                if (x1 <= x2 && x1 < axisx.min) {\n                    if (x2 < axisx.min) {\n                        continue;\n                    }\n\n                    y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x1 = axisx.min;\n                } else if (x2 <= x1 && x2 < axisx.min) {\n                    if (x1 < axisx.min) {\n                        continue;\n                    }\n\n                    y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x2 = axisx.min;\n                }\n\n                // clip with xmax\n                if (x1 >= x2 && x1 > axisx.max) {\n                    if (x2 > axisx.max) {\n                        continue;\n                    }\n\n                    y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x1 = axisx.max;\n                } else if (x2 >= x1 && x2 > axisx.max) {\n                    if (x1 > axisx.max) {\n                        continue;\n                    }\n\n                    y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x2 = axisx.max;\n                }\n\n                if (!areaOpen) {\n                    // open area\n                    ctx.beginPath();\n                    ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                    areaOpen = true;\n                }\n\n                // now first check the case where both is outside\n                if (y1 >= axisy.max && y2 >= axisy.max) {\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                    continue;\n                } else if (y1 <= axisy.min && y2 <= axisy.min) {\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                    continue;\n                }\n\n                // else it's a bit more complicated, there might\n                // be a flat maxed out rectangle first, then a\n                // triangular cutout or reverse; to find these\n                // keep track of the current x values\n                var x1old = x1,\n                    x2old = x2;\n\n                // clip the y values, without shortcutting, we\n                // go through all cases in turn\n\n                // clip with ymin\n                if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                    x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y1 = axisy.min;\n                } else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                    x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y2 = axisy.min;\n                }\n\n                // clip with ymax\n                if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                    x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y1 = axisy.max;\n                } else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                    x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y2 = axisy.max;\n                }\n\n                // if the x value was changed we got a rectangle\n                // to fill\n                if (x1 !== x1old) {\n                    ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                    // it goes to (x1, y1), but we fill that below\n                }\n\n                // fill triangular section, this sometimes result\n                // in redundant points if (x1, y1) hasn't changed\n                // from previous line to, but we just ignore that\n                ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                // fill the other rectangle if it's there\n                if (x2 !== x2old) {\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                    ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                }\n            }\n        }\n\n        /**\n        - drawSeriesLines(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient)\n\n         This function is used for drawing lines or area fill.  In case the series has line decimation function\n         attached, before starting to draw, as an optimization the points will first be decimated.\n\n         The series parameter contains the series to be drawn on ctx context. The plotOffset, plotWidth and\n         plotHeight are the corresponding parameters of flot used to determine the drawing surface.\n         The function getColorOrGradient is used to compute the fill style of lines and area.\n        */\n        function drawSeriesLines(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient) {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            if (series.lines.dashes && ctx.setLineDash) {\n                ctx.setLineDash(series.lines.dashes);\n            }\n\n            var datapoints = {\n                format: series.datapoints.format,\n                points: series.datapoints.points,\n                pointsize: series.datapoints.pointsize\n            };\n\n            if (series.decimate) {\n                datapoints.points = series.decimate(series, series.xaxis.min, series.xaxis.max, plotWidth, series.yaxis.min, series.yaxis.max, plotHeight);\n            }\n\n            var lw = series.lines.lineWidth;\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight, getColorOrGradient);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(datapoints, series.xaxis, series.yaxis, series.lines.fillTowards || 0, ctx);\n            }\n\n            if (lw > 0) {\n                plotLine(datapoints, 0, 0, series.xaxis, series.yaxis, ctx);\n            }\n\n            ctx.restore();\n        }\n\n        /**\n        - drawSeriesPoints(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient)\n\n         This function is used for drawing points using a given symbol. In case the series has points decimation\n         function attached, before starting to draw, as an optimization the points will first be decimated.\n\n         The series parameter contains the series to be drawn on ctx context. The plotOffset, plotWidth and\n         plotHeight are the corresponding parameters of flot used to determine the drawing surface.\n         The function drawSymbol is used to compute and draw the symbol chosen for the points.\n        */\n        function drawSeriesPoints(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient) {\n            function drawCircle(ctx, x, y, radius, shadow, fill) {\n                ctx.moveTo(x + radius, y);\n                ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n            }\n            drawCircle.fill = true;\n            function plotPoints(datapoints, radius, fill, offset, shadow, axisx, axisy, drawSymbolFn) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize;\n\n                ctx.beginPath();\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i],\n                        y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) {\n                        continue;\n                    }\n\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n\n                    drawSymbolFn(ctx, x, y, radius, shadow, fill);\n                }\n                if (drawSymbolFn.fill && !shadow) {\n                    ctx.fill();\n                }\n                ctx.stroke();\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var datapoints = {\n                format: series.datapoints.format,\n                points: series.datapoints.points,\n                pointsize: series.datapoints.pointsize\n            };\n\n            if (series.decimatePoints) {\n                datapoints.points = series.decimatePoints(series, series.xaxis.min, series.xaxis.max, plotWidth, series.yaxis.min, series.yaxis.max, plotHeight);\n            }\n\n            var lw = series.points.lineWidth,\n                radius = series.points.radius,\n                symbol = series.points.symbol,\n                drawSymbolFn;\n\n            if (symbol === 'circle') {\n                drawSymbolFn = drawCircle;\n            } else if (typeof symbol === 'string' && drawSymbol && drawSymbol[symbol]) {\n                drawSymbolFn = drawSymbol[symbol];\n            } else if (typeof drawSymbol === 'function') {\n                drawSymbolFn = drawSymbol;\n            }\n\n            // If the user sets the line width to 0, we change it to a very\n            // small value. A line width of 0 seems to force the default of 1.\n\n            if (lw === 0) {\n                lw = 0.0001;\n            }\n\n            ctx.lineWidth = lw;\n            ctx.fillStyle = getFillStyle(series.points, series.color, null, null, getColorOrGradient);\n            ctx.strokeStyle = series.color;\n            plotPoints(datapoints, radius,\n                true, 0, false,\n                series.xaxis, series.yaxis, drawSymbolFn);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left = x + barLeft,\n                right = x + barRight,\n                bottom = b, top = y,\n                drawLeft, drawRight, drawTop, drawBottom = false,\n                tmp;\n\n            drawLeft = drawRight = drawTop = true;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            }\n            else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n\n            // clip\n            if (right < axisx.min || left > axisx.max ||\n                top < axisy.min || bottom > axisy.max) {\n                return;\n            }\n\n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n\n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n\n            // fill the bar\n            if (fillStyleCallback) {\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fillRect(left, top, right - left, bottom - top)\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom);\n                if (drawLeft) {\n                    c.lineTo(left, top);\n                } else {\n                    c.moveTo(left, top);\n                }\n\n                if (drawTop) {\n                    c.lineTo(right, top);\n                } else {\n                    c.moveTo(right, top);\n                }\n\n                if (drawRight) {\n                    c.lineTo(right, bottom);\n                } else {\n                    c.moveTo(right, bottom);\n                }\n\n                if (drawBottom) {\n                    c.lineTo(left, bottom);\n                } else {\n                    c.moveTo(left, bottom);\n                }\n\n                c.stroke();\n            }\n        }\n\n        /**\n        - drawSeriesBars(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient)\n\n         This function is used for drawing series represented as bars. In case the series has decimation\n         function attached, before starting to draw, as an optimization the points will first be decimated.\n\n         The series parameter contains the series to be drawn on ctx context. The plotOffset, plotWidth and\n         plotHeight are the corresponding parameters of flot used to determine the drawing surface.\n         The function getColorOrGradient is used to compute the fill style of bars.\n        */\n        function drawSeriesBars(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient) {\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    fillTowards = series.bars.fillTowards || 0,\n                    calculatedBottom = fillTowards > axisy.min ? Math.min(axisy.max, fillTowards) : axisy.min;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null) {\n                        continue;\n                    }\n\n                    // Use third point as bottom if pointsize is 3\n                    var bottom = ps === 3 ? points[i + 2] : calculatedBottom;\n                    drawBar(points[i], points[i + 1], bottom, barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var datapoints = {\n                format: series.datapoints.format,\n                points: series.datapoints.points,\n                pointsize: series.datapoints.pointsize\n            };\n\n            if (series.decimate) {\n                datapoints.points = series.decimate(series, series.xaxis.min, series.xaxis.max, plotWidth);\n            }\n\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n\n            var barLeft;\n            var barWidth = series.bars.barWidth[0] || series.bars.barWidth;\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -barWidth;\n                    break;\n                default:\n                    barLeft = -barWidth / 2;\n            }\n\n            var fillStyleCallback = series.bars.fill ? function(bottom, top) {\n                return getFillStyle(series.bars, series.color, bottom, top, getColorOrGradient);\n            } : null;\n\n            plotBars(datapoints, barLeft, barLeft + barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top, getColorOrGradient) {\n            var fill = filloptions.fill;\n            if (!fill) {\n                return null;\n            }\n\n            if (filloptions.fillColor) {\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n            }\n\n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill === \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n\n        this.drawSeriesLines = drawSeriesLines;\n        this.drawSeriesPoints = drawSeriesPoints;\n        this.drawSeriesBars = drawSeriesBars;\n        this.drawBar = drawBar;\n    };\n\n    $.plot.drawSeries = new DrawSeries();\n})(jQuery);\n","(function ($) {\n    'use strict';\n    $.plot.uiConstants = {\n        SNAPPING_CONSTANT: 20,\n        PANHINT_LENGTH_CONSTANT: 10,\n        MINOR_TICKS_COUNT_CONSTANT: 4,\n        TICK_LENGTH_CONSTANT: 10,\n        ZOOM_DISTANCE_MARGIN: 25\n    };\n})(jQuery);\n","/* Pretty handling of log axes.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nCopyright (c) 2015 Ciprian Ceteras cipix2000@gmail.com.\nCopyright (c) 2017 Raluca Portase\nLicensed under the MIT license.\n\nSet axis.mode to \"log\" to enable.\n*/\n\n/* global jQuery*/\n\n/**\n## jquery.flot.logaxis\nThis plugin is used to create logarithmic axis. This includes tick generation,\nformatters and transformers to and from logarithmic representation.\n\n### Methods and hooks\n*/\n\n(function ($) {\n    'use strict';\n\n    var options = {\n        xaxis: {}\n    };\n\n    /*tick generators and formatters*/\n    var PREFERRED_LOG_TICK_VALUES = computePreferedLogTickValues(Number.MAX_VALUE, 10),\n        EXTENDED_LOG_TICK_VALUES = computePreferedLogTickValues(Number.MAX_VALUE, 4);\n\n    function computePreferedLogTickValues(endLimit, rangeStep) {\n        var log10End = Math.floor(Math.log(endLimit) * Math.LOG10E) - 1,\n            log10Start = -log10End,\n            val, range, vals = [];\n\n        for (var power = log10Start; power <= log10End; power++) {\n            range = Math.pow(10, power);\n            for (var mult = 1; mult < 9; mult += rangeStep) {\n                val = range * mult;\n                vals.push(val);\n            }\n        }\n        return vals;\n    }\n\n    /**\n    - logTickGenerator(plot, axis, noTicks)\n\n    Generates logarithmic ticks, depending on axis range.\n    In case the number of ticks that can be generated is less than the expected noTicks/4,\n    a linear tick generation is used.\n    */\n    var logTickGenerator = function (plot, axis, noTicks) {\n        var ticks = [],\n            minIdx = -1,\n            maxIdx = -1,\n            surface = plot.getCanvas(),\n            logTickValues = PREFERRED_LOG_TICK_VALUES,\n            min = clampAxis(axis, plot),\n            max = axis.max;\n\n        if (!noTicks) {\n            noTicks = 0.3 * Math.sqrt(axis.direction === \"x\" ? surface.width : surface.height);\n        }\n\n        PREFERRED_LOG_TICK_VALUES.some(function (val, i) {\n            if (val >= min) {\n                minIdx = i;\n                return true;\n            } else {\n                return false;\n            }\n        });\n\n        PREFERRED_LOG_TICK_VALUES.some(function (val, i) {\n            if (val >= max) {\n                maxIdx = i;\n                return true;\n            } else {\n                return false;\n            }\n        });\n\n        if (maxIdx === -1) {\n            maxIdx = PREFERRED_LOG_TICK_VALUES.length - 1;\n        }\n\n        if (maxIdx - minIdx <= noTicks / 4 && logTickValues.length !== EXTENDED_LOG_TICK_VALUES.length) {\n            //try with multiple of 5 for tick values\n            logTickValues = EXTENDED_LOG_TICK_VALUES;\n            minIdx *= 2;\n            maxIdx *= 2;\n        }\n\n        var lastDisplayed = null,\n            inverseNoTicks = 1 / noTicks,\n            tickValue, pixelCoord, tick;\n\n        // Count the number of tick values would appear, if we can get at least\n        // nTicks / 4 accept them.\n        if (maxIdx - minIdx >= noTicks / 4) {\n            for (var idx = maxIdx; idx >= minIdx; idx--) {\n                tickValue = logTickValues[idx];\n                pixelCoord = (Math.log(tickValue) - Math.log(min)) / (Math.log(max) - Math.log(min));\n                tick = tickValue;\n\n                if (lastDisplayed === null) {\n                    lastDisplayed = {\n                        pixelCoord: pixelCoord,\n                        idealPixelCoord: pixelCoord\n                    };\n                } else {\n                    if (Math.abs(pixelCoord - lastDisplayed.pixelCoord) >= inverseNoTicks) {\n                        lastDisplayed = {\n                            pixelCoord: pixelCoord,\n                            idealPixelCoord: lastDisplayed.idealPixelCoord - inverseNoTicks\n                        };\n                    } else {\n                        tick = null;\n                    }\n                }\n\n                if (tick) {\n                    ticks.push(tick);\n                }\n            }\n            // Since we went in backwards order.\n            ticks.reverse();\n        } else {\n            var tickSize = plot.computeTickSize(min, max, noTicks),\n                customAxis = {min: min, max: max, tickSize: tickSize};\n            ticks = $.plot.linearTickGenerator(customAxis);\n        }\n\n        return ticks;\n    };\n\n    var clampAxis = function (axis, plot) {\n        var min = axis.min,\n            max = axis.max;\n\n        if (min <= 0) {\n            //for empty graph if axis.min is not strictly positive make it 0.1\n            if (axis.datamin === null) {\n                min = axis.min = 0.1;\n            } else {\n                min = processAxisOffset(plot, axis);\n            }\n\n            if (max < min) {\n                axis.max = axis.datamax !== null ? axis.datamax : axis.options.max;\n                axis.options.offset.below = 0;\n                axis.options.offset.above = 0;\n            }\n        }\n\n        return min;\n    }\n\n    /**\n    - logTickFormatter(value, axis, precision)\n\n    This is the corresponding tickFormatter of the logaxis.\n    For a number greater that 10^6 or smaller than 10^(-3), this will be drawn\n    with e representation\n    */\n    var logTickFormatter = function (value, axis, precision) {\n        var tenExponent = value > 0 ? Math.floor(Math.log(value) / Math.LN10) : 0;\n\n        if (precision) {\n            if ((tenExponent >= -4) && (tenExponent <= 7)) {\n                return $.plot.defaultTickFormatter(value, axis, precision);\n            } else {\n                return $.plot.expRepTickFormatter(value, axis, precision);\n            }\n        }\n        if ((tenExponent >= -4) && (tenExponent <= 7)) {\n            //if we have float numbers, return a limited length string(ex: 0.0009 is represented as 0.000900001)\n            var formattedValue = tenExponent < 0 ? value.toFixed(-tenExponent) : value.toFixed(tenExponent + 2);\n            if (formattedValue.indexOf('.') !== -1) {\n                var lastZero = formattedValue.lastIndexOf('0');\n\n                while (lastZero === formattedValue.length - 1) {\n                    formattedValue = formattedValue.slice(0, -1);\n                    lastZero = formattedValue.lastIndexOf('0');\n                }\n\n                //delete the dot if is last\n                if (formattedValue.indexOf('.') === formattedValue.length - 1) {\n                    formattedValue = formattedValue.slice(0, -1);\n                }\n            }\n            return formattedValue;\n        } else {\n            return $.plot.expRepTickFormatter(value, axis);\n        }\n    };\n\n    /*logaxis caracteristic functions*/\n    var logTransform = function (v) {\n        if (v < PREFERRED_LOG_TICK_VALUES[0]) {\n            v = PREFERRED_LOG_TICK_VALUES[0];\n        }\n\n        return Math.log(v);\n    };\n\n    var logInverseTransform = function (v) {\n        return Math.exp(v);\n    };\n\n    var invertedTransform = function (v) {\n        return -v;\n    }\n\n    var invertedLogTransform = function (v) {\n        return -logTransform(v);\n    }\n\n    var invertedLogInverseTransform = function (v) {\n        return logInverseTransform(-v);\n    }\n\n    /**\n    - setDataminRange(plot, axis)\n\n    It is used for clamping the starting point of a logarithmic axis.\n    This will set the axis datamin range to 0.1 or to the first datapoint greater then 0.\n    The function is usefull since the logarithmic representation can not show\n    values less than or equal to 0.\n    */\n    function setDataminRange(plot, axis) {\n        if (axis.options.mode === 'log' && axis.datamin <= 0) {\n            if (axis.datamin === null) {\n                axis.datamin = 0.1;\n            } else {\n                axis.datamin = processAxisOffset(plot, axis);\n            }\n        }\n    }\n\n    function processAxisOffset(plot, axis) {\n        var series = plot.getData(),\n            range = series\n                .filter(function(series) {\n                    return series.xaxis === axis || series.yaxis === axis;\n                })\n                .map(function(series) {\n                    return plot.computeRangeForDataSeries(series, null, isValid);\n                }),\n            min = axis.direction === 'x' ? Math.min(0.1, range[0].xmin) : Math.min(0.1, range[0].ymin);\n\n        axis.min = min;\n\n        return min;\n    }\n\n    function isValid(a) {\n        return a > 0;\n    }\n\n    function init(plot) {\n        plot.hooks.processOptions.push(function (plot) {\n            $.each(plot.getAxes(), function (axisName, axis) {\n                var opts = axis.options;\n                if (opts.mode === 'log') {\n                    axis.tickGenerator = function (axis) {\n                        var noTicks = 11;\n                        return logTickGenerator(plot, axis, noTicks);\n                    };\n                    if (typeof axis.options.tickFormatter !== 'function') {\n                        axis.options.tickFormatter = logTickFormatter;\n                    }\n                    axis.options.transform = opts.inverted ? invertedLogTransform : logTransform;\n                    axis.options.inverseTransform = opts.inverted ? invertedLogInverseTransform : logInverseTransform;\n                    axis.options.autoScaleMargin = 0;\n                    plot.hooks.setRange.push(setDataminRange);\n                } else if (opts.inverted) {\n                    axis.options.transform = invertedTransform;\n                    axis.options.inverseTransform = invertedTransform;\n                }\n            });\n        });\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'log',\n        version: '0.1'\n    });\n\n    $.plot.logTicksGenerator = logTickGenerator;\n    $.plot.logTickFormatter = logTickFormatter;\n})(jQuery);\n","/* Flot plugin that adds some extra symbols for plotting points.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe symbols are accessed as strings through the standard symbol options:\n\n    series: {\n        points: {\n            symbol: \"square\" // or \"diamond\", \"triangle\", \"cross\", \"plus\", \"ellipse\", \"rectangle\"\n        }\n    }\n\n*/\n\n(function ($) {\n    // we normalize the area of each symbol so it is approximately the\n    // same as a circle of the given radius\n\n    var square = function (ctx, x, y, radius, shadow) {\n            // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2\n            var size = radius * Math.sqrt(Math.PI) / 2;\n            ctx.rect(x - size, y - size, size + size, size + size);\n        },\n        rectangle = function (ctx, x, y, radius, shadow) {\n            // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2\n            var size = radius * Math.sqrt(Math.PI) / 2;\n            ctx.rect(x - size, y - size, size + size, size + size);\n        },\n        diamond = function (ctx, x, y, radius, shadow) {\n            // pi * r^2 = 2s^2  =>  s = r * sqrt(pi/2)\n            var size = radius * Math.sqrt(Math.PI / 2);\n            ctx.moveTo(x - size, y);\n            ctx.lineTo(x, y - size);\n            ctx.lineTo(x + size, y);\n            ctx.lineTo(x, y + size);\n            ctx.lineTo(x - size, y);\n            ctx.lineTo(x, y - size);\n        },\n        triangle = function (ctx, x, y, radius, shadow) {\n            // pi * r^2 = 1/2 * s^2 * sin (pi / 3)  =>  s = r * sqrt(2 * pi / sin(pi / 3))\n            var size = radius * Math.sqrt(2 * Math.PI / Math.sin(Math.PI / 3));\n            var height = size * Math.sin(Math.PI / 3);\n            ctx.moveTo(x - size / 2, y + height / 2);\n            ctx.lineTo(x + size / 2, y + height / 2);\n            if (!shadow) {\n                ctx.lineTo(x, y - height / 2);\n                ctx.lineTo(x - size / 2, y + height / 2);\n                ctx.lineTo(x + size / 2, y + height / 2);\n            }\n        },\n        cross = function (ctx, x, y, radius, shadow) {\n            // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2\n            var size = radius * Math.sqrt(Math.PI) / 2;\n            ctx.moveTo(x - size, y - size);\n            ctx.lineTo(x + size, y + size);\n            ctx.moveTo(x - size, y + size);\n            ctx.lineTo(x + size, y - size);\n        },\n        ellipse = function(ctx, x, y, radius, shadow, fill) {\n            if (!shadow) {\n                ctx.moveTo(x + radius, y);\n                ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n            }\n        },\n        plus = function (ctx, x, y, radius, shadow) {\n            var size = radius * Math.sqrt(Math.PI / 2);\n            ctx.moveTo(x - size, y);\n            ctx.lineTo(x + size, y);\n            ctx.moveTo(x, y + size);\n            ctx.lineTo(x, y - size);\n        },\n        handlers = {\n            square: square,\n            rectangle: rectangle,\n            diamond: diamond,\n            triangle: triangle,\n            cross: cross,\n            ellipse: ellipse,\n            plus: plus\n        };\n\n    square.fill = true;\n    rectangle.fill = true;\n    diamond.fill = true;\n    triangle.fill = true;\n    ellipse.fill = true;\n\n    function init(plot) {\n        plot.drawSymbol = handlers;\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        name: 'symbols',\n        version: '1.0'\n    });\n})(jQuery);\n","/* Support for flat 1D data series.\n\nA 1D flat data series is a data series in the form of a regular 1D array. The\nmain reason for using a flat data series is that it performs better, consumes\nless memory and generates less garbage collection than the regular flot format.\n\nExample:\n\n    plot.setData([[[0,0], [1,1], [2,2], [3,3]]]); // regular flot format\n    plot.setData([{flatdata: true, data: [0, 1, 2, 3]}]); // flatdata format\n\nSet series.flatdata to true to enable this plugin.\n\nYou can use series.start to specify the starting index of the series (default is 0)\nYou can use series.step to specify the interval between consecutive indexes of the series (default is 1)\n*/\n\n/* global jQuery*/\n\n(function ($) {\n    'use strict';\n\n    function process1DRawData(plot, series, data, datapoints) {\n        if (series.flatdata === true) {\n            var start = series.start || 0;\n            var step = typeof series.step === 'number' ? series.step : 1;\n            datapoints.pointsize = 2;\n            for (var i = 0, j = 0; i < data.length; i++, j += 2) {\n                datapoints.points[j] = start + (i * step);\n                datapoints.points[j + 1] = data[i];\n            }\n            if (datapoints.points !== undefined) {\n                datapoints.points.length = data.length * 2;\n            } else {\n                datapoints.points = [];\n            }\n        }\n    }\n\n    $.plot.plugins.push({\n        init: function(plot) {\n            plot.hooks.processRawData.push(process1DRawData);\n        },\n        name: 'flatdata',\n        version: '0.0.2'\n    });\n})(jQuery);\n","/* Flot plugin for adding the ability to pan and zoom the plot.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nCopyright (c) 2016 Ciprian Ceteras.\nCopyright (c) 2017 Raluca Portase.\nLicensed under the MIT license.\n\n*/\n\n/**\n## jquery.flot.navigate.js\n\nThis flot plugin is used for adding the ability to pan and zoom the plot.\nA higher level overview is available at [interactions](interactions.md) documentation.\n\nThe default behaviour is scrollwheel up/down to zoom in, drag\nto pan. The plugin defines plot.zoom({ center }), plot.zoomOut() and\nplot.pan( offset ) so you easily can add custom controls. It also fires\n\"plotpan\" and \"plotzoom\" events, useful for synchronizing plots.\n\nThe plugin supports these options:\n```js\n    zoom: {\n        interactive: false,\n        active: false,\n        amount: 1.5         // 2 = 200% (zoom in), 0.5 = 50% (zoom out)\n    }\n\n    pan: {\n        interactive: false,\n        active: false,\n        cursor: \"move\",     // CSS mouse cursor value used when dragging, e.g. \"pointer\"\n        frameRate: 20,\n        mode: \"smart\"       // enable smart pan mode\n    }\n\n    xaxis: {\n        axisZoom: true, //zoom axis when mouse over it is allowed\n        plotZoom: true, //zoom axis is allowed for plot zoom\n        axisPan: true, //pan axis when mouse over it is allowed\n        plotPan: true //pan axis is allowed for plot pan\n    }\n\n    yaxis: {\n        axisZoom: true, //zoom axis when mouse over it is allowed\n        plotZoom: true, //zoom axis is allowed for plot zoom\n        axisPan: true, //pan axis when mouse over it is allowed\n        plotPan: true //pan axis is allowed for plot pan\n    }\n```\n**interactive** enables the built-in drag/click behaviour. If you enable\ninteractive for pan, then you'll have a basic plot that supports moving\naround; the same for zoom.\n\n**active** is true after a touch tap on plot. This enables plot navigation.\nOnce activated, zoom and pan cannot be deactivated. When the plot becomes active,\n\"plotactivated\" event is triggered.\n\n**amount** specifies the default amount to zoom in (so 1.5 = 150%) relative to\nthe current viewport.\n\n**cursor** is a standard CSS mouse cursor string used for visual feedback to the\nuser when dragging.\n\n**frameRate** specifies the maximum number of times per second the plot will\nupdate itself while the user is panning around on it (set to null to disable\nintermediate pans, the plot will then not update until the mouse button is\nreleased).\n\nExample API usage:\n```js\n    plot = $.plot(...);\n\n    // zoom default amount in on the pixel ( 10, 20 )\n    plot.zoom({ center: { left: 10, top: 20 } });\n\n    // zoom out again\n    plot.zoomOut({ center: { left: 10, top: 20 } });\n\n    // zoom 200% in on the pixel (10, 20)\n    plot.zoom({ amount: 2, center: { left: 10, top: 20 } });\n\n    // pan 100 pixels to the left and 20 down\n    plot.pan({ left: -100, top: 20 })\n```\n\nHere, \"center\" specifies where the center of the zooming should happen. Note\nthat this is defined in pixel space, not the space of the data points (you can\nuse the p2c helpers on the axes in Flot to help you convert between these).\n\n**amount** is the amount to zoom the viewport relative to the current range, so\n1 is 100% (i.e. no change), 1.5 is 150% (zoom in), 0.7 is 70% (zoom out). You\ncan set the default in the options.\n*/\n\n/* eslint-enable */\n(function($) {\n    'use strict';\n\n    var options = {\n        zoom: {\n            interactive: false,\n            active: false,\n            amount: 1.5 // how much to zoom relative to current position, 2 = 200% (zoom in), 0.5 = 50% (zoom out)\n        },\n        pan: {\n            interactive: false,\n            active: false,\n            cursor: \"move\",\n            frameRate: 60\n        },\n        xaxis: {\n            axisZoom: true, //zoom axis when mouse over it is allowed\n            plotZoom: true, //zoom axis is allowed for plot zoom\n            axisPan: true, //pan axis when mouse over it is allowed\n            plotPan: true //pan axis is allowed for plot pan\n        },\n        yaxis: {\n            axisZoom: true,\n            plotZoom: true,\n            axisPan: true,\n            plotPan: true\n        }\n    };\n\n    var saturated = $.plot.saturated;\n    var browser = $.plot.browser;\n    var SNAPPING_CONSTANT = $.plot.uiConstants.SNAPPING_CONSTANT;\n    var PANHINT_LENGTH_CONSTANT = $.plot.uiConstants.PANHINT_LENGTH_CONSTANT;\n\n    function init(plot) {\n        var panAxes = null;\n        var canDrag = false;\n\n        function onZoomClick(e, zoomOut, amount) {\n            var page = browser.getPageXY(e);\n\n            var c = plot.offset();\n            c.left = page.X - c.left;\n            c.top = page.Y - c.top;\n\n            var ec = plot.getPlaceholder().offset();\n            ec.left = page.X - ec.left;\n            ec.top = page.Y - ec.top;\n\n            var axes = plot.getXAxes().concat(plot.getYAxes()).filter(function (axis) {\n                var box = axis.box;\n                if (box !== undefined) {\n                    return (ec.left > box.left) && (ec.left < box.left + box.width) &&\n                        (ec.top > box.top) && (ec.top < box.top + box.height);\n                }\n            });\n\n            if (axes.length === 0) {\n                axes = undefined;\n            }\n\n            if (zoomOut) {\n                plot.zoomOut({\n                    center: c,\n                    axes: axes,\n                    amount: amount\n                });\n            } else {\n                plot.zoom({\n                    center: c,\n                    axes: axes,\n                    amount: amount\n                });\n            }\n        }\n\n        var prevCursor = 'default',\n            panHint = null,\n            panTimeout = null,\n            plotState,\n            isPanAction = false;\n\n        function onMouseWheel(e, delta) {\n            var maxAbsoluteDeltaOnMac = 1,\n                isMacScroll = Math.abs(e.originalEvent.deltaY) <= maxAbsoluteDeltaOnMac,\n                defaultNonMacScrollAmount = null,\n                macMagicRatio = 50,\n                amount = isMacScroll ? 1 + Math.abs(e.originalEvent.deltaY) / macMagicRatio : defaultNonMacScrollAmount;\n\n            if (isPanAction) {\n                onDragEnd(e);\n            }\n\n            if (plot.getOptions().zoom.active) {\n                e.preventDefault();\n                onZoomClick(e, delta < 0, amount);\n                return false;\n            }\n        }\n\n        plot.navigationState = function(startPageX, startPageY) {\n            var axes = this.getAxes();\n            var result = {};\n            Object.keys(axes).forEach(function(axisName) {\n                var axis = axes[axisName];\n                result[axisName] = {\n                    navigationOffset: { below: axis.options.offset.below || 0,\n                        above: axis.options.offset.above || 0},\n                    axisMin: axis.min,\n                    axisMax: axis.max,\n                    diagMode: false\n                }\n            });\n\n            result.startPageX = startPageX || 0;\n            result.startPageY = startPageY || 0;\n            return result;\n        }\n\n        function onMouseDown(e) {\n            canDrag = true;\n        }\n\n        function onMouseUp(e) {\n            canDrag = false;\n        }\n\n        function isLeftMouseButtonPressed(e) {\n            return e.button === 0;\n        }\n\n        function onDragStart(e) {\n            if (!canDrag || !isLeftMouseButtonPressed(e)) {\n                return false;\n            }\n\n            isPanAction = true;\n            var page = browser.getPageXY(e);\n\n            var ec = plot.getPlaceholder().offset();\n            ec.left = page.X - ec.left;\n            ec.top = page.Y - ec.top;\n\n            panAxes = plot.getXAxes().concat(plot.getYAxes()).filter(function (axis) {\n                var box = axis.box;\n                if (box !== undefined) {\n                    return (ec.left > box.left) && (ec.left < box.left + box.width) &&\n                        (ec.top > box.top) && (ec.top < box.top + box.height);\n                }\n            });\n\n            if (panAxes.length === 0) {\n                panAxes = undefined;\n            }\n\n            var c = plot.getPlaceholder().css('cursor');\n            if (c) {\n                prevCursor = c;\n            }\n\n            plot.getPlaceholder().css('cursor', plot.getOptions().pan.cursor);\n            plotState = plot.navigationState(page.X, page.Y);\n        }\n\n        function onDrag(e) {\n            var page = browser.getPageXY(e);\n            var frameRate = plot.getOptions().pan.frameRate;\n\n            if (frameRate === -1) {\n                plot.smartPan({\n                    x: plotState.startPageX - page.X,\n                    y: plotState.startPageY - page.Y\n                }, plotState, panAxes);\n\n                return;\n            }\n\n            if (panTimeout || !frameRate) return;\n\n            panTimeout = setTimeout(function() {\n                plot.smartPan({\n                    x: plotState.startPageX - page.X,\n                    y: plotState.startPageY - page.Y\n                }, plotState, panAxes);\n\n                panTimeout = null;\n            }, 1 / frameRate * 1000);\n        }\n\n        function onDragEnd(e) {\n            if (panTimeout) {\n                clearTimeout(panTimeout);\n                panTimeout = null;\n            }\n\n            isPanAction = false;\n            var page = browser.getPageXY(e);\n\n            plot.getPlaceholder().css('cursor', prevCursor);\n            plot.smartPan({\n                x: plotState.startPageX - page.X,\n                y: plotState.startPageY - page.Y\n            }, plotState, panAxes);\n            panHint = null;\n        }\n\n        function onDblClick(e) {\n            plot.activate();\n\n            var axes = plot.getTouchedAxis(e.clientX, e.clientY),\n                event;\n            if (axes[0]) {\n                event = new $.Event('re-center', { detail: {\n                    axisTouched: axes[0]\n                }});\n            } else {\n                event = new $.Event('re-center', {detail: e});\n            }\n            plot.getPlaceholder().trigger(event);\n        }\n\n        function onClick(e) {\n            plot.activate();\n\n            if (isPanAction) {\n                onDragEnd(e);\n            }\n\n            return false;\n        }\n\n        plot.activate = function() {\n            var o = plot.getOptions();\n            if (!o.pan.active || !o.zoom.active) {\n                o.pan.active = true;\n                o.zoom.active = true;\n                plot.getPlaceholder().trigger(\"plotactivated\", [plot]);\n            }\n        }\n\n        function bindEvents(plot, eventHolder) {\n            var o = plot.getOptions();\n            if (o.zoom.interactive) {\n                eventHolder.mousewheel(onMouseWheel);\n            }\n\n            if (o.pan.interactive) {\n                plot.addEventHandler(\"dragstart\", onDragStart, eventHolder, 0);\n                plot.addEventHandler(\"drag\", onDrag, eventHolder, 0);\n                plot.addEventHandler(\"dragend\", onDragEnd, eventHolder, 0);\n                eventHolder.bind(\"mousedown\", onMouseDown);\n                eventHolder.bind(\"mouseup\", onMouseUp);\n            }\n\n            eventHolder.dblclick(onDblClick);\n            eventHolder.click(onClick);\n        }\n\n        plot.zoomOut = function(args) {\n            if (!args) {\n                args = {};\n            }\n\n            if (!args.amount) {\n                args.amount = plot.getOptions().zoom.amount;\n            }\n\n            args.amount = 1 / args.amount;\n            plot.zoom(args);\n        };\n\n        plot.zoom = function(args) {\n            if (!args) {\n                args = {};\n            }\n\n            var c = args.center,\n                amount = args.amount || plot.getOptions().zoom.amount,\n                w = plot.width(),\n                h = plot.height(),\n                axes = args.axes || plot.getAxes();\n\n            if (!c) {\n                c = {\n                    left: w / 2,\n                    top: h / 2\n                };\n            }\n\n            var xf = c.left / w,\n                yf = c.top / h,\n                minmax = {\n                    x: {\n                        min: c.left - xf * w / amount,\n                        max: c.left + (1 - xf) * w / amount\n                    },\n                    y: {\n                        min: c.top - yf * h / amount,\n                        max: c.top + (1 - yf) * h / amount\n                    }\n                };\n\n            for (var key in axes) {\n                if (!axes.hasOwnProperty(key)) {\n                    continue;\n                }\n\n                var axis = axes[key],\n                    opts = axis.options,\n                    min = minmax[axis.direction].min,\n                    max = minmax[axis.direction].max,\n                    navigationOffset = axis.options.offset;\n\n                //skip axis without axisZoom when zooming only on certain axis or axis without plotZoom for zoom on entire plot\n                if ((!opts.axisZoom && args.axes) || (!args.axes && !opts.plotZoom)) {\n                    continue;\n                }\n\n                min = $.plot.saturated.saturate(axis.c2p(min));\n                max = $.plot.saturated.saturate(axis.c2p(max));\n                if (min > max) {\n                    // make sure min < max\n                    var tmp = min;\n                    min = max;\n                    max = tmp;\n                }\n\n                var offsetBelow = $.plot.saturated.saturate(navigationOffset.below - (axis.min - min));\n                var offsetAbove = $.plot.saturated.saturate(navigationOffset.above - (axis.max - max));\n                opts.offset = { below: offsetBelow, above: offsetAbove };\n            };\n\n            plot.setupGrid();\n            plot.draw();\n\n            if (!args.preventEvent) {\n                plot.getPlaceholder().trigger(\"plotzoom\", [plot, args]);\n            }\n        };\n\n        plot.pan = function(args) {\n            var delta = {\n                x: +args.left,\n                y: +args.top\n            };\n\n            if (isNaN(delta.x)) delta.x = 0;\n            if (isNaN(delta.y)) delta.y = 0;\n\n            $.each(args.axes || plot.getAxes(), function(_, axis) {\n                var opts = axis.options,\n                    d = delta[axis.direction];\n\n                //skip axis without axisPan when panning only on certain axis or axis without plotPan for pan the entire plot\n                if ((!opts.axisPan && args.axes) || (!opts.plotPan && !args.axes)) {\n                    return;\n                }\n\n                if (d !== 0) {\n                    var navigationOffsetBelow = saturated.saturate(axis.c2p(axis.p2c(axis.min) - d) - axis.c2p(axis.p2c(axis.min))),\n                        navigationOffsetAbove = saturated.saturate(axis.c2p(axis.p2c(axis.max) - d) - axis.c2p(axis.p2c(axis.max)));\n\n                    if (!isFinite(navigationOffsetBelow)) {\n                        navigationOffsetBelow = 0;\n                    }\n\n                    if (!isFinite(navigationOffsetAbove)) {\n                        navigationOffsetAbove = 0;\n                    }\n\n                    opts.offset = {\n                        below: saturated.saturate(navigationOffsetBelow + (opts.offset.below || 0)),\n                        above: saturated.saturate(navigationOffsetAbove + (opts.offset.above || 0))\n                    };\n                }\n            });\n\n            plot.setupGrid();\n            plot.draw();\n            if (!args.preventEvent) {\n                plot.getPlaceholder().trigger(\"plotpan\", [plot, args]);\n            }\n        };\n\n        plot.recenter = function(args) {\n            $.each(args.axes || plot.getAxes(), function(_, axis) {\n                if (args.axes) {\n                    if (this.direction === 'x') {\n                        axis.options.offset = { below: 0 };\n                    } else if (this.direction === 'y') {\n                        axis.options.offset = { above: 0 };\n                    }\n                } else {\n                    axis.options.offset = { below: 0, above: 0 };\n                }\n            });\n            plot.setupGrid();\n            plot.draw();\n        };\n\n        var shouldSnap = function(delta) {\n            return (Math.abs(delta.y) < SNAPPING_CONSTANT && Math.abs(delta.x) >= SNAPPING_CONSTANT) ||\n                (Math.abs(delta.x) < SNAPPING_CONSTANT && Math.abs(delta.y) >= SNAPPING_CONSTANT);\n        }\n\n        // adjust delta so the pan action is constrained on the vertical or horizontal direction\n        // it the movements in the other direction are small\n        var adjustDeltaToSnap = function(delta) {\n            if (Math.abs(delta.x) < SNAPPING_CONSTANT && Math.abs(delta.y) >= SNAPPING_CONSTANT) {\n                return {x: 0, y: delta.y};\n            }\n\n            if (Math.abs(delta.y) < SNAPPING_CONSTANT && Math.abs(delta.x) >= SNAPPING_CONSTANT) {\n                return {x: delta.x, y: 0};\n            }\n\n            return delta;\n        }\n\n        var isDiagonalMode = function(delta) {\n            if (Math.abs(delta.x) > 0 && Math.abs(delta.y) > 0) {\n                return true;\n            }\n            return false;\n        }\n\n        var restoreAxisOffset = function(axes, initialState, delta) {\n            var axis;\n            Object.keys(axes).forEach(function(axisName) {\n                axis = axes[axisName];\n                if (delta[axis.direction] === 0) {\n                    axis.options.offset.below = initialState[axisName].navigationOffset.below;\n                    axis.options.offset.above = initialState[axisName].navigationOffset.above;\n                }\n            });\n        }\n\n        var prevDelta = { x: 0, y: 0 };\n        plot.smartPan = function(delta, initialState, panAxes, preventEvent) {\n            var snap = shouldSnap(delta),\n                axes = plot.getAxes(),\n                opts;\n            delta = adjustDeltaToSnap(delta);\n\n            if (isDiagonalMode(delta)) {\n                initialState.diagMode = true;\n            }\n\n            if (snap && initialState.diagMode === true) {\n                initialState.diagMode = false;\n                restoreAxisOffset(axes, initialState, delta);\n            }\n\n            if (snap) {\n                panHint = {\n                    start: {\n                        x: initialState.startPageX - plot.offset().left + plot.getPlotOffset().left,\n                        y: initialState.startPageY - plot.offset().top + plot.getPlotOffset().top\n                    },\n                    end: {\n                        x: initialState.startPageX - delta.x - plot.offset().left + plot.getPlotOffset().left,\n                        y: initialState.startPageY - delta.y - plot.offset().top + plot.getPlotOffset().top\n                    }\n                }\n            } else {\n                panHint = {\n                    start: {\n                        x: initialState.startPageX - plot.offset().left + plot.getPlotOffset().left,\n                        y: initialState.startPageY - plot.offset().top + plot.getPlotOffset().top\n                    },\n                    end: false\n                }\n            }\n\n            if (isNaN(delta.x)) delta.x = 0;\n            if (isNaN(delta.y)) delta.y = 0;\n\n            if (panAxes) {\n                axes = panAxes;\n            }\n\n            var axis, axisMin, axisMax, p, d;\n            Object.keys(axes).forEach(function(axisName) {\n                axis = axes[axisName];\n                axisMin = axis.min;\n                axisMax = axis.max;\n                opts = axis.options;\n\n                d = delta[axis.direction];\n                p = prevDelta[axis.direction];\n\n                //skip axis without axisPan when panning only on certain axis or axis without plotPan for pan the entire plot\n                if ((!opts.axisPan && panAxes) || (!panAxes && !opts.plotPan)) {\n                    return;\n                }\n\n                if (d !== 0) {\n                    var navigationOffsetBelow = saturated.saturate(axis.c2p(axis.p2c(axisMin) - (p - d)) - axis.c2p(axis.p2c(axisMin))),\n                        navigationOffsetAbove = saturated.saturate(axis.c2p(axis.p2c(axisMax) - (p - d)) - axis.c2p(axis.p2c(axisMax)));\n\n                    if (!isFinite(navigationOffsetBelow)) {\n                        navigationOffsetBelow = 0;\n                    }\n\n                    if (!isFinite(navigationOffsetAbove)) {\n                        navigationOffsetAbove = 0;\n                    }\n\n                    axis.options.offset.below = saturated.saturate(navigationOffsetBelow + (axis.options.offset.below || 0));\n                    axis.options.offset.above = saturated.saturate(navigationOffsetAbove + (axis.options.offset.above || 0));\n                }\n            });\n\n            prevDelta = delta;\n            plot.setupGrid();\n            plot.draw();\n\n            if (!preventEvent) {\n                plot.getPlaceholder().trigger(\"plotpan\", [plot, delta, panAxes, initialState]);\n            }\n        };\n\n        function shutdown(plot, eventHolder) {\n            eventHolder.unbind(\"mousewheel\", onMouseWheel);\n            eventHolder.unbind(\"mousedown\", onMouseDown);\n            eventHolder.unbind(\"mouseup\", onMouseUp);\n            eventHolder.unbind(\"dragstart\", onDragStart);\n            eventHolder.unbind(\"drag\", onDrag);\n            eventHolder.unbind(\"dragend\", onDragEnd);\n            eventHolder.unbind(\"dblclick\", onDblClick);\n            eventHolder.unbind(\"click\", onClick);\n\n            if (panTimeout) clearTimeout(panTimeout);\n        }\n\n        function drawOverlay(plot, ctx) {\n            if (panHint) {\n                ctx.strokeStyle = 'rgba(96, 160, 208, 0.7)';\n                ctx.lineWidth = 2;\n                ctx.lineJoin = \"round\";\n                var startx = Math.round(panHint.start.x),\n                    starty = Math.round(panHint.start.y),\n                    endx, endy;\n\n                if (panAxes) {\n                    if (panAxes[0].direction === 'x') {\n                        endy = Math.round(panHint.start.y);\n                        endx = Math.round(panHint.end.x);\n                    } else if (panAxes[0].direction === 'y') {\n                        endx = Math.round(panHint.start.x);\n                        endy = Math.round(panHint.end.y);\n                    }\n                } else {\n                    endx = Math.round(panHint.end.x);\n                    endy = Math.round(panHint.end.y);\n                }\n\n                ctx.beginPath();\n\n                if (panHint.end === false) {\n                    ctx.moveTo(startx, starty - PANHINT_LENGTH_CONSTANT);\n                    ctx.lineTo(startx, starty + PANHINT_LENGTH_CONSTANT);\n\n                    ctx.moveTo(startx + PANHINT_LENGTH_CONSTANT, starty);\n                    ctx.lineTo(startx - PANHINT_LENGTH_CONSTANT, starty);\n                } else {\n                    var dirX = starty === endy;\n\n                    ctx.moveTo(startx - (dirX ? 0 : PANHINT_LENGTH_CONSTANT), starty - (dirX ? PANHINT_LENGTH_CONSTANT : 0));\n                    ctx.lineTo(startx + (dirX ? 0 : PANHINT_LENGTH_CONSTANT), starty + (dirX ? PANHINT_LENGTH_CONSTANT : 0));\n\n                    ctx.moveTo(startx, starty);\n                    ctx.lineTo(endx, endy);\n\n                    ctx.moveTo(endx - (dirX ? 0 : PANHINT_LENGTH_CONSTANT), endy - (dirX ? PANHINT_LENGTH_CONSTANT : 0));\n                    ctx.lineTo(endx + (dirX ? 0 : PANHINT_LENGTH_CONSTANT), endy + (dirX ? PANHINT_LENGTH_CONSTANT : 0));\n                }\n\n                ctx.stroke();\n            }\n        }\n\n        plot.getTouchedAxis = function(touchPointX, touchPointY) {\n            var ec = plot.getPlaceholder().offset();\n            ec.left = touchPointX - ec.left;\n            ec.top = touchPointY - ec.top;\n\n            var axis = plot.getXAxes().concat(plot.getYAxes()).filter(function (axis) {\n                var box = axis.box;\n                if (box !== undefined) {\n                    return (ec.left > box.left) && (ec.left < box.left + box.width) &&\n                            (ec.top > box.top) && (ec.top < box.top + box.height);\n                }\n            });\n\n            return axis;\n        }\n\n        plot.hooks.drawOverlay.push(drawOverlay);\n        plot.hooks.bindEvents.push(bindEvents);\n        plot.hooks.shutdown.push(shutdown);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'navigate',\n        version: '1.3'\n    });\n})(jQuery);\n","/* Flot plugin for stacking data sets rather than overlyaing them.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe plugin assumes the data is sorted on x (or y if stacking horizontally).\nFor line charts, it is assumed that if a line has an undefined gap (from a\nnull point), then the line above it should have the same gap - insert zeros\ninstead of \"null\" if you want another behaviour. This also holds for the start\nand end of the chart. Note that stacking a mix of positive and negative values\nin most instances doesn't make sense (so it looks weird).\n\nTwo or more series are stacked when their \"stack\" attribute is set to the same\nkey (which can be any number or string or just \"true\"). To specify the default\nstack, you can set the stack option like this:\n\n    series: {\n        stack: null/false, true, or a key (number/string)\n    }\n\nYou can also specify it for a single series, like this:\n\n    $.plot( $(\"#placeholder\"), [{\n        data: [ ... ],\n        stack: true\n    }])\n\nThe stacking order is determined by the order of the data series in the array\n(later series end up on top of the previous).\n\nInternally, the plugin modifies the datapoints in each series, adding an\noffset to the y value. For line series, extra data points are inserted through\ninterpolation. If there's a second y value, it's also adjusted (e.g for bar\ncharts or filled areas).\n\n*/\n\n(function ($) {\n    var options = {\n        series: { stack: null } // or number/string\n    };\n\n    function init(plot) {\n        function findMatchingSeries(s, allseries) {\n            var res = null;\n            for (var i = 0; i < allseries.length; ++i) {\n                if (s === allseries[i]) break;\n\n                if (allseries[i].stack === s.stack) {\n                    res = allseries[i];\n                }\n            }\n\n            return res;\n        }\n\n        function addBottomPoints (s, datapoints) {\n            var formattedPoints = [];\n            for (var i = 0; i < datapoints.points.length; i += 2) {\n                formattedPoints.push(datapoints.points[i]);\n                formattedPoints.push(datapoints.points[i + 1]);\n                formattedPoints.push(0);\n            }\n\n            datapoints.format.push({\n                x: false,\n                y: true,\n                number: true,\n                required: false,\n                computeRange: s.yaxis.options.autoScale !== 'none',\n                defaultValue: 0\n            });\n            datapoints.points = formattedPoints;\n            datapoints.pointsize = 3;\n        }\n\n        function stackData(plot, s, datapoints) {\n            if (s.stack == null || s.stack === false) return;\n\n            var needsBottom = s.bars.show || (s.lines.show && s.lines.fill);\n            var hasBottom = datapoints.pointsize > 2 && (horizontal ? datapoints.format[2].x : datapoints.format[2].y);\n            // Series data is missing bottom points - need to format\n            if (needsBottom && !hasBottom) {\n                addBottomPoints(s, datapoints);\n            }\n\n            var other = findMatchingSeries(s, plot.getData());\n            if (!other) return;\n\n            var ps = datapoints.pointsize,\n                points = datapoints.points,\n                otherps = other.datapoints.pointsize,\n                otherpoints = other.datapoints.points,\n                newpoints = [],\n                px, py, intery, qx, qy, bottom,\n                withlines = s.lines.show,\n                horizontal = s.bars.horizontal,\n                withsteps = withlines && s.lines.steps,\n                fromgap = true,\n                keyOffset = horizontal ? 1 : 0,\n                accumulateOffset = horizontal ? 0 : 1,\n                i = 0, j = 0, l, m;\n\n            while (true) {\n                if (i >= points.length) break;\n\n                l = newpoints.length;\n\n                if (points[i] == null) {\n                    // copy gaps\n                    for (m = 0; m < ps; ++m) {\n                        newpoints.push(points[i + m]);\n                    }\n\n                    i += ps;\n                } else if (j >= otherpoints.length) {\n                    // for lines, we can't use the rest of the points\n                    if (!withlines) {\n                        for (m = 0; m < ps; ++m) {\n                            newpoints.push(points[i + m]);\n                        }\n                    }\n\n                    i += ps;\n                } else if (otherpoints[j] == null) {\n                    // oops, got a gap\n                    for (m = 0; m < ps; ++m) {\n                        newpoints.push(null);\n                    }\n\n                    fromgap = true;\n                    j += otherps;\n                } else {\n                    // cases where we actually got two points\n                    px = points[i + keyOffset];\n                    py = points[i + accumulateOffset];\n                    qx = otherpoints[j + keyOffset];\n                    qy = otherpoints[j + accumulateOffset];\n                    bottom = 0;\n\n                    if (px === qx) {\n                        for (m = 0; m < ps; ++m) {\n                            newpoints.push(points[i + m]);\n                        }\n\n                        newpoints[l + accumulateOffset] += qy;\n                        bottom = qy;\n\n                        i += ps;\n                        j += otherps;\n                    } else if (px > qx) {\n                        // we got past point below, might need to\n                        // insert interpolated extra point\n                        if (withlines && i > 0 && points[i - ps] != null) {\n                            intery = py + (points[i - ps + accumulateOffset] - py) * (qx - px) / (points[i - ps + keyOffset] - px);\n                            newpoints.push(qx);\n                            newpoints.push(intery + qy);\n                            for (m = 2; m < ps; ++m) {\n                                newpoints.push(points[i + m]);\n                            }\n\n                            bottom = qy;\n                        }\n\n                        j += otherps;\n                    } else { // px < qx\n                        if (fromgap && withlines) {\n                            // if we come from a gap, we just skip this point\n                            i += ps;\n                            continue;\n                        }\n\n                        for (m = 0; m < ps; ++m) {\n                            newpoints.push(points[i + m]);\n                        }\n\n                        // we might be able to interpolate a point below,\n                        // this can give us a better y\n                        if (withlines && j > 0 && otherpoints[j - otherps] != null) {\n                            bottom = qy + (otherpoints[j - otherps + accumulateOffset] - qy) * (px - qx) / (otherpoints[j - otherps + keyOffset] - qx);\n                        }\n\n                        newpoints[l + accumulateOffset] += bottom;\n\n                        i += ps;\n                    }\n\n                    fromgap = false;\n\n                    if (l !== newpoints.length && needsBottom) {\n                        newpoints[l + 2] += bottom;\n                    }\n                }\n\n                // maintain the line steps invariant\n                if (withsteps && l !== newpoints.length && l > 0 &&\n                    newpoints[l] !== null &&\n                    newpoints[l] !== newpoints[l - ps] &&\n                    newpoints[l + 1] !== newpoints[l - ps + 1]) {\n                    for (m = 0; m < ps; ++m) {\n                        newpoints[l + ps + m] = newpoints[l + m];\n                    }\n\n                    newpoints[l + 1] = newpoints[l - ps + 1];\n                }\n            }\n\n            datapoints.points = newpoints;\n        }\n\n        plot.hooks.processDatapoints.push(stackData);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'stack',\n        version: '1.2'\n    });\n})(jQuery);\n","/* global jQuery */\n\n(function($) {\n    'use strict';\n\n    var options = {\n        pan: {\n            enableTouch: false\n        }\n    };\n\n    var ZOOM_DISTANCE_MARGIN = $.plot.uiConstants.ZOOM_DISTANCE_MARGIN;\n\n    function init(plot) {\n        plot.hooks.processOptions.push(initTouchNavigation);\n    }\n\n    function initTouchNavigation(plot, options) {\n        var gestureState = {\n                zoomEnable: false,\n                prevDistance: null,\n                prevTapTime: 0,\n                prevPanPosition: { x: 0, y: 0 },\n                prevTapPosition: { x: 0, y: 0 }\n            },\n            navigationState = {\n                prevTouchedAxis: 'none',\n                currentTouchedAxis: 'none',\n                touchedAxis: null,\n                navigationConstraint: 'unconstrained'\n            },\n            pan, pinch, doubleTap;\n\n        function bindEvents(plot, eventHolder) {\n            var o = plot.getOptions();\n\n            if (o.pan.interactive) {\n                eventHolder[0].addEventListener('panstart', pan.start, false);\n                eventHolder[0].addEventListener('pandrag', pan.drag, false);\n                eventHolder[0].addEventListener('panend', pan.end, false);\n                eventHolder[0].addEventListener('pinchstart', pinch.start, false);\n                eventHolder[0].addEventListener('pinchdrag', pinch.drag, false);\n                eventHolder[0].addEventListener('pinchend', pinch.end, false);\n                eventHolder[0].addEventListener('doubletap', doubleTap.recenterPlot, false);\n            }\n        }\n\n        function shutdown(plot, eventHolder) {\n            eventHolder[0].removeEventListener('panstart', pan.start);\n            eventHolder[0].removeEventListener('pandrag', pan.drag);\n            eventHolder[0].removeEventListener('panend', pan.end);\n            eventHolder[0].removeEventListener('pinchstart', pinch.start);\n            eventHolder[0].removeEventListener('pinchdrag', pinch.drag);\n            eventHolder[0].removeEventListener('pinchend', pinch.end);\n            eventHolder[0].removeEventListener('doubletap', doubleTap.recenterPlot);\n        }\n\n        pan = {\n            start: function(e) {\n                presetNavigationState(e, 'pan', gestureState);\n                updateData(e, 'pan', gestureState, navigationState);\n            },\n\n            drag: function(e) {\n                presetNavigationState(e, 'pan', gestureState);\n                plot.pan({\n                    left: delta(e, 'pan', gestureState).x,\n                    top: delta(e, 'pan', gestureState).y,\n                    axes: navigationState.touchedAxis\n                });\n                updatePrevPanPosition(e, 'pan', gestureState, navigationState);\n            },\n\n            end: function(e) {\n                presetNavigationState(e, 'pan', gestureState);\n                if (wasPinchEvent(e, gestureState)) {\n                    updateprevPanPosition(e, 'pan', gestureState, navigationState);\n                }\n            }\n        };\n        var pinchDragTimeout;\n        pinch = {\n            start: function(e) {\n                if (pinchDragTimeout) {\n                    clearTimeout(pinchDragTimeout);\n                    pinchDragTimeout = null;\n                }\n                presetNavigationState(e, 'pinch', gestureState);\n                setPrevDistance(e, gestureState);\n                updateData(e, 'pinch', gestureState, navigationState);\n            },\n\n            drag: function(e) {\n                if (pinchDragTimeout) {\n                    return;\n                }\n                pinchDragTimeout = setTimeout(function() {\n                    presetNavigationState(e, 'pinch', gestureState);\n                    plot.pan({\n                        left: delta(e, 'pinch', gestureState).x,\n                        top: delta(e, 'pinch', gestureState).y,\n                        axes: navigationState.touchedAxis\n                    });\n                    updatePrevPanPosition(e, 'pinch', gestureState, navigationState);\n\n                    var dist = pinchDistance(e);\n\n                    if (gestureState.zoomEnable || Math.abs(dist - gestureState.prevDistance) > ZOOM_DISTANCE_MARGIN) {\n                        zoomPlot(plot, e, gestureState, navigationState);\n\n                        //activate zoom mode\n                        gestureState.zoomEnable = true;\n                    }\n                    pinchDragTimeout = null;\n                }, 1000 / 60);\n            },\n\n            end: function(e) {\n                if (pinchDragTimeout) {\n                    clearTimeout(pinchDragTimeout);\n                    pinchDragTimeout = null;\n                }\n                presetNavigationState(e, 'pinch', gestureState);\n                gestureState.prevDistance = null;\n            }\n        };\n\n        doubleTap = {\n            recenterPlot: function(e) {\n                recenterPlotOnDoubleTap(plot, e, gestureState, navigationState);\n            }\n        };\n\n        if (options.pan.enableTouch === true) {\n            plot.hooks.bindEvents.push(bindEvents);\n            plot.hooks.shutdown.push(shutdown);\n        }\n\n        function presetNavigationState(e, gesture, gestureState) {\n            navigationState.touchedAxis = getAxis(plot, e, gesture, navigationState);\n            if (noAxisTouched(navigationState)) {\n                navigationState.navigationConstraint = 'unconstrained';\n            } else {\n                navigationState.navigationConstraint = 'axisConstrained';\n            }\n        }\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'navigateTouch',\n        version: '0.3'\n    });\n\n    function recenterPlotOnDoubleTap(plot, e, gestureState, navigationState) {\n        checkAxesForDoubleTap(plot, e, navigationState);\n        if ((navigationState.currentTouchedAxis === 'x' && navigationState.prevTouchedAxis === 'x') ||\n            (navigationState.currentTouchedAxis === 'y' && navigationState.prevTouchedAxis === 'y') ||\n            (navigationState.currentTouchedAxis === 'none' && navigationState.prevTouchedAxis === 'none')) {\n            plot.recenter({ axes: navigationState.touchedAxis });\n        }\n    }\n\n    function checkAxesForDoubleTap(plot, e, navigationState) {\n        var axis = plot.getTouchedAxis(e.detail.firstTouch.x, e.detail.firstTouch.y);\n        if (axis[0] !== undefined) {\n            navigationState.prevTouchedAxis = axis[0].direction;\n        }\n\n        axis = plot.getTouchedAxis(e.detail.secondTouch.x, e.detail.secondTouch.y);\n        if (axis[0] !== undefined) {\n            navigationState.touchedAxis = axis;\n            navigationState.currentTouchedAxis = axis[0].direction;\n        }\n\n        if (noAxisTouched(navigationState)) {\n            navigationState.touchedAxis = null;\n            navigationState.prevTouchedAxis = 'none';\n            navigationState.currentTouchedAxis = 'none';\n        }\n    }\n\n    function zoomPlot(plot, e, gestureState, navigationState) {\n        var offset = plot.offset(),\n            center = {\n                left: 0,\n                top: 0\n            },\n            zoomAmount = pinchDistance(e) / gestureState.prevDistance,\n            dist = pinchDistance(e);\n\n        center.left = getPoint(e, 'pinch').x - offset.left;\n        center.top = getPoint(e, 'pinch').y - offset.top;\n\n        // send the computed touched axis to the zoom function so that it only zooms on that one\n        plot.zoom({\n            center: center,\n            amount: zoomAmount,\n            axes: navigationState.touchedAxis\n        });\n        gestureState.prevDistance = dist;\n    }\n\n    function wasPinchEvent(e, gestureState) {\n        return (gestureState.zoomEnable && e.detail.touches.length === 1);\n    }\n\n    function getAxis(plot, e, gesture, navigationState) {\n        if (e.type === 'pinchstart') {\n            var axisTouch1 = plot.getTouchedAxis(e.detail.touches[0].pageX, e.detail.touches[0].pageY);\n            var axisTouch2 = plot.getTouchedAxis(e.detail.touches[1].pageX, e.detail.touches[1].pageY);\n\n            if (axisTouch1.length === axisTouch2.length && axisTouch1.toString() === axisTouch2.toString()) {\n                return axisTouch1;\n            }\n        } else if (e.type === 'panstart') {\n            return plot.getTouchedAxis(e.detail.touches[0].pageX, e.detail.touches[0].pageY);\n        } else if (e.type === 'pinchend') {\n            //update axis since instead on pinch, a pan event is made\n            return plot.getTouchedAxis(e.detail.touches[0].pageX, e.detail.touches[0].pageY);\n        } else {\n            return navigationState.touchedAxis;\n        }\n    }\n\n    function noAxisTouched(navigationState) {\n        return (!navigationState.touchedAxis || navigationState.touchedAxis.length === 0);\n    }\n\n    function setPrevDistance(e, gestureState) {\n        gestureState.prevDistance = pinchDistance(e);\n    }\n\n    function updateData(e, gesture, gestureState, navigationState) {\n        var axisDir,\n            point = getPoint(e, gesture);\n\n        switch (navigationState.navigationConstraint) {\n            case 'unconstrained':\n                navigationState.touchedAxis = null;\n                gestureState.prevTapPosition = {\n                    x: gestureState.prevPanPosition.x,\n                    y: gestureState.prevPanPosition.y\n                };\n                gestureState.prevPanPosition = {\n                    x: point.x,\n                    y: point.y\n                };\n                break;\n            case 'axisConstrained':\n                axisDir = navigationState.touchedAxis[0].direction;\n                navigationState.currentTouchedAxis = axisDir;\n                gestureState.prevTapPosition[axisDir] = gestureState.prevPanPosition[axisDir];\n                gestureState.prevPanPosition[axisDir] = point[axisDir];\n                break;\n            default:\n                break;\n        }\n    }\n\n    function distance(x1, y1, x2, y2) {\n        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    function pinchDistance(e) {\n        var t1 = e.detail.touches[0],\n            t2 = e.detail.touches[1];\n        return distance(t1.pageX, t1.pageY, t2.pageX, t2.pageY);\n    }\n\n    function updatePrevPanPosition(e, gesture, gestureState, navigationState) {\n        var point = getPoint(e, gesture);\n\n        switch (navigationState.navigationConstraint) {\n            case 'unconstrained':\n                gestureState.prevPanPosition.x = point.x;\n                gestureState.prevPanPosition.y = point.y;\n                break;\n            case 'axisConstrained':\n                gestureState.prevPanPosition[navigationState.currentTouchedAxis] =\n                point[navigationState.currentTouchedAxis];\n                break;\n            default:\n                break;\n        }\n    }\n\n    function delta(e, gesture, gestureState) {\n        var point = getPoint(e, gesture);\n\n        return {\n            x: point.x - gestureState.prevPanPosition.x,\n            y: point.y - gestureState.prevPanPosition.y\n        }\n    }\n\n    function getPoint(e, gesture) {\n        if (gesture === 'pinch') {\n            return {\n                x: (e.detail.touches[0].pageX + e.detail.touches[1].pageX) / 2,\n                y: (e.detail.touches[0].pageY + e.detail.touches[1].pageY) / 2\n            }\n        } else {\n            return {\n                x: e.detail.touches[0].pageX,\n                y: e.detail.touches[0].pageY\n            }\n        }\n    }\n})(jQuery);\n","/* global jQuery */\n\n/**\n## jquery.flot.hover.js\n\nThis plugin is used for mouse hover and tap on a point of plot series.\nIt supports the following options:\n```js\ngrid: {\n    hoverable: false, //to trigger plothover event on mouse hover or tap on a point\n    clickable: false //to trigger plotclick event on mouse hover\n}\n```\n\nIt listens to native mouse move event or click, as well as artificial generated\ntap and touchevent.\n\nWhen the mouse is over a point or a tap on a point is performed, that point or\nthe correscponding bar will be highlighted and a \"plothover\" event will be generated.\n\nCustom \"touchevent\" is triggered when any touch interaction is made. Hover plugin\nhandles this events by unhighlighting all of the previously highlighted points and generates\n\"plothovercleanup\" event to notify any part that is handling plothover (for exemple to cleanup\nthe tooltip from webcharts).\n*/\n\n(function($) {\n    'use strict';\n\n    var options = {\n        grid: {\n            hoverable: false,\n            clickable: false\n        }\n    };\n\n    var browser = $.plot.browser;\n\n    function init(plot) {\n        plot.hooks.processOptions.push(initHover);\n    }\n\n    function initHover(plot, options) {\n        var highlights = [];\n\n        var eventType = {\n            click: 'click',\n            hover: 'hover'\n        }\n\n        var lastMouseMoveEvent = plot.getPlaceholder()[0].lastMouseMoveEvent;\n\n        plot.highlight = highlight;\n        plot.unhighlight = unhighlight;\n\n        function bindEvents(plot, eventHolder) {\n            var o = plot.getOptions();\n\n            if (o.grid.hoverable || o.grid.clickable) {\n                eventHolder[0].addEventListener('touchevent', triggerCleanupEvent, false);\n                eventHolder[0].addEventListener('tap', tap.generatePlothoverEvent, false);\n            }\n\n            if (options.grid.clickable) {\n                eventHolder.click(onClick);\n            }\n\n            if (options.grid.hoverable) {\n                eventHolder.mousemove(onMouseMove);\n\n                // Use bind, rather than .mouseleave, because we officially\n                // still support jQuery 1.2.6, which doesn't define a shortcut\n                // for mouseenter or mouseleave.  This was a bug/oversight that\n                // was fixed somewhere around 1.3.x.  We can return to using\n                // .mouseleave when we drop support for 1.2.6.\n\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\n            }\n        }\n\n        function shutdown(plot, eventHolder) {\n            eventHolder[0].removeEventListener('tap', tap.generatePlothoverEvent);\n            eventHolder[0].removeEventListener('tap', triggerCleanupEvent);\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n            highlights = [];\n        }\n\n        function doTriggerClickHoverEvent(event, eventType, searchDistance) {\n            var series = plot.getData();\n            if (event !== undefined \n                && series.length > 0 \n                && series[0].xaxis.c2p !== undefined \n                && series[0].yaxis.c2p !== undefined) {\n                var eventToTrigger = \"plot\" + eventType;\n                var seriesFlag = eventType + \"able\";\n                triggerClickHoverEvent(eventToTrigger, event,\n                    function(i) {\n                        return series[i][seriesFlag] !== false;\n                    }, searchDistance);\n            }\n        }\n\n        var tap = {\n            generatePlothoverEvent: function (e) {\n                var o = plot.getOptions(),\n                    newEvent = new CustomEvent('mouseevent');\n\n                //transform from touch event to mouse event format\n                newEvent.pageX = e.detail.changedTouches[0].pageX;\n                newEvent.pageY = e.detail.changedTouches[0].pageY;\n                newEvent.clientX = e.detail.changedTouches[0].clientX;\n                newEvent.clientY = e.detail.changedTouches[0].clientY;\n\n                if (o.grid.hoverable) {\n                    doTriggerClickHoverEvent(newEvent, eventType.hover, 30);\n                }\n                return false;\n            }\n        };\n\n        if (options.grid.hoverable || options.grid.clickable) {\n            plot.hooks.bindEvents.push(bindEvents);\n            plot.hooks.shutdown.push(shutdown);\n            plot.hooks.drawOverlay.push(drawOverlay);\n            plot.hooks.processRawData.push(processRawData);\n        }\n\n        function onMouseMove(e) {\n            lastMouseMoveEvent = e;\n            plot.getPlaceholder()[0].lastMouseMoveEvent = e;\n            doTriggerClickHoverEvent(e, eventType.hover);\n        }\n\n        function onMouseLeave(e) {\n            lastMouseMoveEvent = undefined;\n            plot.getPlaceholder()[0].lastMouseMoveEvent = undefined;\n            triggerClickHoverEvent(\"plothover\", e,\n                function(i) {\n                    return false;\n                });\n        }\n\n        function onClick(e) {\n            doTriggerClickHoverEvent(e, eventType.click);\n        }\n\n        function triggerCleanupEvent() {\n            plot.unhighlight();\n            plot.getPlaceholder().trigger('plothovercleanup');\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter, searchDistance) {\n            var options = plot.getOptions(),\n                offset = plot.offset(),\n                page = browser.getPageXY(event),\n                canvasX = page.X - offset.left,\n                canvasY = page.Y - offset.top,\n                pos = plot.c2p({\n                    left: canvasX,\n                    top: canvasY\n                }),\n                distance = searchDistance !== undefined ? searchDistance : options.grid.mouseActiveRadius;\n\n            pos.pageX = page.X;\n            pos.pageY = page.Y;\n\n            var item = plot.findNearbyItem(canvasX, canvasY, seriesFilter, distance);\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left, 10);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top, 10);\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if ((h.auto === eventname &&\n                        !(item && h.series === item.series &&\n                            h.point[0] === item.datapoint[0] &&\n                            h.point[1] === item.datapoint[1])) || !item) {\n                        unhighlight(h.series, h.point);\n                    }\n                }\n\n                if (item) {\n                    highlight(item.series, item.datapoint, eventname);\n                }\n            }\n\n            plot.getPlaceholder().trigger(eventname, [pos, item]);\n        }\n\n        function highlight(s, point, auto) {\n            if (typeof s === \"number\") {\n                s = plot.getData()[s];\n            }\n\n            if (typeof point === \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i === -1) {\n                highlights.push({\n                    series: s,\n                    point: point,\n                    auto: auto\n                });\n\n                plot.triggerRedrawOverlay();\n            } else if (!auto) {\n                highlights[i].auto = false;\n            }\n        }\n\n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                plot.triggerRedrawOverlay();\n                return;\n            }\n\n            if (typeof s === \"number\") {\n                s = plot.getData()[s];\n            }\n\n            if (typeof point === \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i !== -1) {\n                highlights.splice(i, 1);\n\n                plot.triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series === s &&\n                    h.point[0] === p[0] &&\n                    h.point[1] === p[1]) {\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n\n        function processRawData() {\n            triggerCleanupEvent();\n            doTriggerClickHoverEvent(lastMouseMoveEvent, eventType.hover);\n        }\n\n        function drawOverlay(plot, octx, overlay) {\n            var plotOffset = plot.getPlotOffset(),\n                i, hi;\n\n            octx.save();\n            octx.translate(plotOffset.left, plotOffset.top);\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show) drawBarHighlight(hi.series, hi.point, octx);\n                else drawPointHighlight(hi.series, hi.point, octx, plot);\n            }\n            octx.restore();\n        }\n    }\n\n    function drawPointHighlight(series, point, octx, plot) {\n        var x = point[0],\n            y = point[1],\n            axisx = series.xaxis,\n            axisy = series.yaxis,\n            highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n\n        if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) {\n            return;\n        }\n\n        var pointRadius = series.points.radius + series.points.lineWidth / 2;\n        octx.lineWidth = pointRadius;\n        octx.strokeStyle = highlightColor;\n        var radius = 1.5 * pointRadius;\n        x = axisx.p2c(x);\n        y = axisy.p2c(y);\n\n        octx.beginPath();\n        var symbol = series.points.symbol;\n        if (symbol === 'circle') {\n            octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n        } else if (typeof symbol === 'string' && plot.drawSymbol && plot.drawSymbol[symbol]) {\n            plot.drawSymbol[symbol](octx, x, y, radius, false);\n        }\n\n        octx.closePath();\n        octx.stroke();\n    }\n\n    function drawBarHighlight(series, point, octx) {\n        var highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n            fillStyle = highlightColor,\n            barLeft;\n\n        var barWidth = series.bars.barWidth[0] || series.bars.barWidth;\n        switch (series.bars.align) {\n            case \"left\":\n                barLeft = 0;\n                break;\n            case \"right\":\n                barLeft = -barWidth;\n                break;\n            default:\n                barLeft = -barWidth / 2;\n        }\n\n        octx.lineWidth = series.bars.lineWidth;\n        octx.strokeStyle = highlightColor;\n\n        var fillTowards = series.bars.fillTowards || 0,\n            bottom = fillTowards > series.yaxis.min ? Math.min(series.yaxis.max, fillTowards) : series.yaxis.min;\n\n        $.plot.drawSeries.drawBar(point[0], point[1], point[2] || bottom, barLeft, barLeft + barWidth,\n            function() {\n                return fillStyle;\n            }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'hover',\n        version: '0.1'\n    });\n})(jQuery);\n","\n/* global jQuery */\n\n(function($) {\n    'use strict';\n\n    var options = {\n        pan: {\n            enableTouch: false\n        }\n    };\n\n    function init(plot) {\n        plot.hooks.processOptions.push(initTouchNavigation);\n    }\n\n    function initTouchNavigation(plot, options) {\n        var gestureState = {\n                twoTouches: false,\n                currentTapStart: { x: 0, y: 0 },\n                currentTapEnd: { x: 0, y: 0 },\n                prevTap: { x: 0, y: 0 },\n                currentTap: { x: 0, y: 0 },\n                interceptedLongTap: false,\n                allowEventPropagation: false,\n                prevTapTime: null,\n                tapStartTime: null,\n                longTapTriggerId: null\n            },\n            maxDistanceBetweenTaps = 20,\n            maxIntervalBetweenTaps = 500,\n            maxLongTapDistance = 20,\n            minLongTapDuration = 1500,\n            pressedTapDuration = 125,\n            mainEventHolder;\n\n        function interpretGestures(e) {\n            var o = plot.getOptions();\n\n            if (!o.pan.active && !o.zoom.active) {\n                return;\n            }\n\n            updateOnMultipleTouches(e);\n            mainEventHolder.dispatchEvent(new CustomEvent('touchevent', { detail: e }));\n\n            if (isPinchEvent(e)) {\n                executeAction(e, 'pinch');\n            } else {\n                executeAction(e, 'pan');\n                if (!wasPinchEvent(e)) {\n                    if (isDoubleTap(e)) {\n                        executeAction(e, 'doubleTap');\n                    }\n                    executeAction(e, 'tap');\n                    executeAction(e, 'longTap');\n                }\n            }\n        }\n\n        function executeAction(e, gesture) {\n            switch (gesture) {\n                case 'pan':\n                    pan[e.type](e);\n                    break;\n                case 'pinch':\n                    pinch[e.type](e);\n                    break;\n                case 'doubleTap':\n                    doubleTap.onDoubleTap(e);\n                    break;\n                case 'longTap':\n                    longTap[e.type](e);\n                    break;\n                case 'tap':\n                    tap[e.type](e);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        function bindEvents(plot, eventHolder) {\n            mainEventHolder = eventHolder[0];\n            eventHolder[0].addEventListener('touchstart', interpretGestures, false);\n            eventHolder[0].addEventListener('touchmove', interpretGestures, false);\n            eventHolder[0].addEventListener('touchend', interpretGestures, false);\n        }\n\n        function shutdown(plot, eventHolder) {\n            eventHolder[0].removeEventListener('touchstart', interpretGestures);\n            eventHolder[0].removeEventListener('touchmove', interpretGestures);\n            eventHolder[0].removeEventListener('touchend', interpretGestures);\n            if (gestureState.longTapTriggerId) {\n                clearTimeout(gestureState.longTapTriggerId);\n                gestureState.longTapTriggerId = null;\n            }\n        }\n\n        var pan = {\n            touchstart: function(e) {\n                updatePrevForDoubleTap();\n                updateCurrentForDoubleTap(e);\n                updateStateForLongTapStart(e);\n\n                mainEventHolder.dispatchEvent(new CustomEvent('panstart', { detail: e }));\n            },\n\n            touchmove: function(e) {\n                preventEventPropagation(e);\n\n                updateCurrentForDoubleTap(e);\n                updateStateForLongTapEnd(e);\n\n                if (!gestureState.allowEventPropagation) {\n                    mainEventHolder.dispatchEvent(new CustomEvent('pandrag', { detail: e }));\n                }\n            },\n\n            touchend: function(e) {\n                preventEventPropagation(e);\n\n                if (wasPinchEvent(e)) {\n                    mainEventHolder.dispatchEvent(new CustomEvent('pinchend', { detail: e }));\n                    mainEventHolder.dispatchEvent(new CustomEvent('panstart', { detail: e }));\n                } else if (noTouchActive(e)) {\n                    mainEventHolder.dispatchEvent(new CustomEvent('panend', { detail: e }));\n                }\n            }\n        };\n\n        var pinch = {\n            touchstart: function(e) {\n                mainEventHolder.dispatchEvent(new CustomEvent('pinchstart', { detail: e }));\n            },\n\n            touchmove: function(e) {\n                preventEventPropagation(e);\n                gestureState.twoTouches = isPinchEvent(e);\n                if (!gestureState.allowEventPropagation) {\n                    mainEventHolder.dispatchEvent(new CustomEvent('pinchdrag', { detail: e }));\n                }\n            },\n\n            touchend: function(e) {\n                preventEventPropagation(e);\n            }\n        };\n\n        var doubleTap = {\n            onDoubleTap: function(e) {\n                preventEventPropagation(e);\n                mainEventHolder.dispatchEvent(new CustomEvent('doubletap', { detail: e }));\n            }\n        };\n\n        var longTap = {\n            touchstart: function(e) {\n                longTap.waitForLongTap(e);\n            },\n\n            touchmove: function(e) {\n            },\n\n            touchend: function(e) {\n                if (gestureState.longTapTriggerId) {\n                    clearTimeout(gestureState.longTapTriggerId);\n                    gestureState.longTapTriggerId = null;\n                }\n            },\n\n            isLongTap: function(e) {\n                var currentTime = new Date().getTime(),\n                    tapDuration = currentTime - gestureState.tapStartTime;\n                if (tapDuration >= minLongTapDuration && !gestureState.interceptedLongTap) {\n                    if (distance(gestureState.currentTapStart.x, gestureState.currentTapStart.y, gestureState.currentTapEnd.x, gestureState.currentTapEnd.y) < maxLongTapDistance) {\n                        gestureState.interceptedLongTap = true;\n                        return true;\n                    }\n                }\n                return false;\n            },\n\n            waitForLongTap: function(e) {\n                var longTapTrigger = function() {\n                    if (longTap.isLongTap(e)) {\n                        mainEventHolder.dispatchEvent(new CustomEvent('longtap', { detail: e }));\n                    }\n                    gestureState.longTapTriggerId = null;\n                };\n                if (!gestureState.longTapTriggerId) {\n                    gestureState.longTapTriggerId = setTimeout(longTapTrigger, minLongTapDuration);\n                }\n            }\n        };\n\n        var tap = {\n            touchstart: function(e) {\n                gestureState.tapStartTime = new Date().getTime();\n            },\n\n            touchmove: function(e) {\n            },\n\n            touchend: function(e) {\n                if (tap.isTap(e)) {\n                    mainEventHolder.dispatchEvent(new CustomEvent('tap', { detail: e }));\n                    preventEventPropagation(e);\n                }\n            },\n\n            isTap: function(e) {\n                var currentTime = new Date().getTime(),\n                    tapDuration = currentTime - gestureState.tapStartTime;\n                if (tapDuration <= pressedTapDuration) {\n                    if (distance(gestureState.currentTapStart.x, gestureState.currentTapStart.y, gestureState.currentTapEnd.x, gestureState.currentTapEnd.y) < maxLongTapDistance) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        };\n\n        if (options.pan.enableTouch === true) {\n            plot.hooks.bindEvents.push(bindEvents);\n            plot.hooks.shutdown.push(shutdown);\n        };\n\n        function updatePrevForDoubleTap() {\n            gestureState.prevTap = {\n                x: gestureState.currentTap.x,\n                y: gestureState.currentTap.y\n            };\n        };\n\n        function updateCurrentForDoubleTap(e) {\n            gestureState.currentTap = {\n                x: e.touches[0].pageX,\n                y: e.touches[0].pageY\n            };\n        }\n\n        function updateStateForLongTapStart(e) {\n            gestureState.tapStartTime = new Date().getTime();\n            gestureState.interceptedLongTap = false;\n            gestureState.currentTapStart = {\n                x: e.touches[0].pageX,\n                y: e.touches[0].pageY\n            };\n            gestureState.currentTapEnd = {\n                x: e.touches[0].pageX,\n                y: e.touches[0].pageY\n            };\n        };\n\n        function updateStateForLongTapEnd(e) {\n            gestureState.currentTapEnd = {\n                x: e.touches[0].pageX,\n                y: e.touches[0].pageY\n            };\n        };\n\n        function isDoubleTap(e) {\n            var currentTime = new Date().getTime(),\n                intervalBetweenTaps = currentTime - gestureState.prevTapTime;\n\n            if (intervalBetweenTaps >= 0 && intervalBetweenTaps < maxIntervalBetweenTaps) {\n                if (distance(gestureState.prevTap.x, gestureState.prevTap.y, gestureState.currentTap.x, gestureState.currentTap.y) < maxDistanceBetweenTaps) {\n                    e.firstTouch = gestureState.prevTap;\n                    e.secondTouch = gestureState.currentTap;\n                    return true;\n                }\n            }\n            gestureState.prevTapTime = currentTime;\n            return false;\n        }\n\n        function preventEventPropagation(e) {\n            if (!gestureState.allowEventPropagation) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }\n\n        function distance(x1, y1, x2, y2) {\n            return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n        }\n\n        function noTouchActive(e) {\n            return (e.touches && e.touches.length === 0);\n        }\n\n        function wasPinchEvent(e) {\n            return (gestureState.twoTouches && e.touches.length === 1);\n        }\n\n        function updateOnMultipleTouches(e) {\n            if (e.touches.length >= 3) {\n                gestureState.allowEventPropagation = true;\n            } else {\n                gestureState.allowEventPropagation = false;\n            }\n        }\n\n        function isPinchEvent(e) {\n            if (e.touches && e.touches.length >= 2) {\n                if (e.touches[0].target === plot.getEventHolder() &&\n                    e.touches[1].target === plot.getEventHolder()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'navigateTouch',\n        version: '0.3'\n    });\n})(jQuery);\n","/* Pretty handling of time axes.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nSet axis.format to \"time\" to enable. See the section \"Time series data\" in\nAPI.txt for details.\n*/\n\n/** ## jquery.flot.absRelTime.js\n\nThis plugin is used to format the time axis in absolute time representation as\nwell as relative time representation.\n\nIt supports the following options:\n```js\nxaxis: {\n    timezone: null, // \"browser\" for local to the client or timezone for timezone-js\n    timeformat: null, // format string to use\n    twelveHourClock: false, // 12 or 24 time in time mode\n    monthNames: null // list of names of months\n    timeEpoch: '0000-12-31T18:00:00' // A time in UTC string format to use as an offset for the display of dates (see below)\n}\nyaxis: {\n    timeEpoch: '0000-12-31T18:00:00' // A time in UTC string format to use as an offset for the display of dates (see below)\n}\n```\n\nDepending upon the timeformat axis parameter value, the axis tick formatter will\nchoose between an absolute time representation if the value begins with '%A' or\nrelative time for timeformat '%r'.\n\nTime formatting options may follow the %A or %r specification in the timeformat string.\nThey take the form of:\n\n<(hh|HH):mm[:ss[.S+]]> or <#T> for localized version of time\n\n'<HH:mm>'          24-hour format\n'<hh:mm:ss>'       12-hour format\n'<hh:mm:ss.SSS>'   12-hour format, with three-digit fractional seconds\n'<#T.SSS>'         localized format, with three-digit fractional seconds\n\nDate formatting options will be honored when following the %A specification. Note that it\ncan be used in combination with the time formatting (with both sets of options between\nthe '<>' characters. If both date and time formatting options are present, currently time\nwill always be displayed first, and the date will be displayed on a newline.\n\nDate formats are as follows:\n\n<(dd/MM|MM/dd)/yy(yy)> or <#d> for localized version of date\n\n'<dd/MM>'         Day/Month  (no year)\n'<MM/dd/yy>'      Month/Day/2-digit year\n'<MM/dd/yyyy>'    Month/Day/4-digit year\n'<#d>'            localized date format (per preferred language setting of browser)\n\nIf the format for an axis is 'time', inside processOptions hook the tickGenerator\nand tickFormatter of the axis will be overrided with the custom ones used by time axes.\n\nThe formatted values look like in the example bellow:\n\n|format|value(s)|formatted value(s)|\n|------|----:|--------------:|\n|Absolute time|0|12:00:00 AM 1/1/0001|\n|Absolute time|300|12:05:00 AM 1/1/0001|\n|Relative Time|0, 300, 600|00:00:00, 00:05:00, 00:10:00|\n|Relative Time|300, 600, 900|00:00:00, 00:05:00, 00:10:00|\n\n### Relative time axis\nA relative time axis will show the time values with respect to the first data sample.\nBasically, the first datapoint from the points array will be considered time 00:00:00:00.\nIf the difference between two datapoints is small, the milliseconds will apear.\nOtherwise, the time representation will contain only the hour, minute and second.\nNOTE: If a formatString is provided, any date format will be ignored.\n\n### Absolute time axis\nThe absolute time representation contains, beside the hours, minutes and seconds\ncorresponding to the sample the date and year.\nThe value will be splitted on two rows, where the first row is the time and\nthe the second one the date in gregorian date format.\n*/\n\n(function($) {\n    'use strict';\n\n    var options = {\n        xaxis: {\n            timezone: null, // \"browser\" for local to the client or timezone for timezone-js\n            timeformat: null, // format string to use\n            twelveHourClock: false, // 12 or 24 time in time mode\n            monthNames: null, // list of names of months\n            // the UTC date in the form of \"total milliseconds from\" to use as the epoch for formatted values\n            // the default will format a date of \"0 milliseconds\" to be \"12:00:00 AM 01/01/0000\"\n            timeEpoch: -62135596800000\n        },\n        yaxis: {\n            // the UTC date in the form of \"total milliseconds from\" to use as the epoch for formatted values\n            // the default will format a date of \"0 milliseconds\" to be \"12:00:00 AM 01/01/0000\"\n            timeEpoch: -62135596800000\n        }\n    };\n\n    var floorInBase = $.plot.saturated.floorInBase;\n\n    // Returns a string with the date d formatted according to fmt.\n    // A subset of the Open Group's strftime format is supported.\n\n    function formatDate(d, fmt, monthNames, dayNames, showMilliseconds, axis) {\n        if (typeof d.strftime === \"function\") {\n            return d.strftime(fmt);\n        }\n\n        var leftPad = function(n, pad) {\n            n = \"\" + n;\n            if (pad) pad = \"\" + pad;\n            else pad = \"0\";\n\n            return n.length === 1 ? pad + n : n;\n        };\n\n        var padNTimes = function(n, pad, nTimes, right) {\n            n = \"\" + n;\n            if (pad) pad = \"\" + pad;\n            else pad = \"0\";\n\n            while (n.length < nTimes) {\n                if (right === true) {\n                    n = n + pad;\n                } else {\n                    n = pad + n;\n                }\n            }\n            return n;\n        };\n\n        function addMilliseconds(date, ms) {\n            var parts = date.split(' ');\n            if (parts.length > 1) {\n                var sufix = parts[parts.length - 1];\n                parts.splice(parts.length - 1, 1);\n\n                return parts.join(' ') + ms + ' ' + sufix;\n            } else {\n                return date + ms;\n            }\n        }\n\n        function formatLanguage() {\n            // horrible hack\n            if (window.NIEmbeddedBrowser && window.NIEmbeddedBrowser.formatLanguage) {\n                return window.NIEmbeddedBrowser.formatLanguage;\n            }\n\n            return navigator.locale || 'en-US';\n        }\n\n        // Returns the set of options to be used by an instance of Intl.DateTimeFormat\n        function getFormatterOptions(formatString) {\n            var options = {};\n            if (formatString === undefined || formatString === null) {\n                return options;\n            }\n\n            if (formatString.indexOf(\"#d\") >= 0) {\n                options['year'] = \"numeric\";\n                options['month'] = \"numeric\";\n                options['day'] = \"numeric\";\n            } else {\n                if (formatString.indexOf(\"yyyy\") >= 0) {\n                    options['year'] = \"numeric\";\n                } else if (formatString.indexOf(\"yy\") >= 0) {\n                    options['year'] = \"2-digit\";\n                }\n\n                options['month'] = \"numeric\";\n                options['day'] = \"numeric\";\n            }\n\n            if (formatString.indexOf(\"#T\") >= 0) {\n                options['hour'] = \"numeric\";\n                options['minute'] = \"numeric\";\n                options['second'] = \"numeric\";\n            } else { // format has either \"hh\" or \"HH\" (which always will show minutes)\n                options['hour'] = \"2-digit\";\n                options['minute'] = \"2-digit\";\n\n                if (formatString.indexOf(\"ss\") >= 0) {\n                    options['second'] = \"2-digit\";\n                }\n\n                options['hour12'] = formatString.indexOf(\"hh\") >= 0;\n            }\n\n            return options;\n        }\n\n        function getFormattedDateString(date, formatString, formatOptions, locale) {\n            var showYear = formatString.indexOf(\"yy\") >= 0 || formatString.indexOf(\"#d\") >= 0;\n            if (!showYear && !(formatString.indexOf(\"MM\") >= 0)) {\n                return \"\";\n            }\n\n            // System format\n            if (formatString.indexOf(\"#d\") >= 0) {\n                return Intl.DateTimeFormat(locale, {year: 'numeric', month: 'numeric', day: 'numeric'}).format(date);\n            }\n\n            // Custom format\n            var formatParts = Intl.DateTimeFormat(locale, formatOptions).formatToParts(date);\n            var formatPartsTypeList = formatParts.map(({type, value}) => { return type; });\n            var dayIndex = formatPartsTypeList.indexOf('day');\n            var monthIndex = formatPartsTypeList.indexOf('month');\n            var dayMonthDelimiter = formatParts[(monthIndex + dayIndex) / 2].value;\n            var dayValue = leftPad(formatParts[dayIndex].value);\n            var monthValue = leftPad(formatParts[monthIndex].value);\n            var yearValue = showYear ? formatParts[formatPartsTypeList.indexOf('year')].value : \"\";\n\n            if (showYear) {\n                var padAmount = formatString.indexOf(\"yyyy\") >= 0 ? 4 : 2;\n                yearValue = padNTimes(yearValue, \"0\", padAmount);\n            }\n\n            if (formatString.indexOf(\"dd\") < formatString.indexOf(\"MM\")) {\n                return dayValue + dayMonthDelimiter + monthValue + (showYear ? dayMonthDelimiter + yearValue : \"\");\n            } else {\n                return monthValue + dayMonthDelimiter + dayValue + (showYear ? dayMonthDelimiter + yearValue : \"\");\n            }\n        }\n\n        function getFractionalSecondsString(milliseconds, formatString, forceFractionalSeconds) {\n            var fractionalSecondsIndex = formatString.indexOf(\".S\");\n            var fractionalSecondsSearch = new RegExp(\".S+\", \"g\");\n            var fallbackDigitCount = forceFractionalSeconds ? 3 : 0;\n            var numberOfFractionalSeconds = fractionalSecondsIndex > 0 ? fractionalSecondsSearch.exec(formatString)[0].length - 1 : fallbackDigitCount;\n            var fractionalSecondsString = padNTimes(milliseconds, \"0\", 3);\n            fractionalSecondsString = padNTimes(fractionalSecondsString, \"0\", numberOfFractionalSeconds, true);\n            fractionalSecondsString = numberOfFractionalSeconds > 0 ? fractionalSecondsString.substring(0, numberOfFractionalSeconds) : \"\";\n            return fractionalSecondsString;\n        }\n\n        function getFormattedTimeString(date, formatString, formatOptions, locale) {\n            var showTime = formatString.indexOf(\"hh\") >= 0 || formatString.indexOf(\"HH\") >= 0 || formatString.indexOf(\"#T\") >= 0;\n            if (!showTime) {\n                return \"\";\n            }\n\n            var fractionalSecondsString = getFractionalSecondsString(date.getMilliseconds(), formatString);\n\n            // System format\n            if (formatString.indexOf(\"#T\") >= 0) {\n                var formattedDate = Intl.DateTimeFormat(locale, {hour: 'numeric', minute: 'numeric', second: 'numeric'}).format(date);\n                if (fractionalSecondsString !== \"\") {\n                    var lastDigitSearch = new RegExp(\"[0-9](?!.*[0-9])\", \"g\");\n                    lastDigitSearch.test(formattedDate);\n                    formattedDate = [formattedDate.slice(0, lastDigitSearch.lastIndex), \".\" + fractionalSecondsString, formattedDate.slice(lastDigitSearch.lastIndex)].join('');\n                }\n\n                return formattedDate;\n            }\n\n            // Custom format\n            var formatParts = Intl.DateTimeFormat(locale, formatOptions).formatToParts(date);\n            var formatPartsTypeList = formatParts.map(({type, value}) => { return type.toLowerCase(); });\n            var hourIndex = formatPartsTypeList.indexOf('hour');\n            var minuteIndex = formatPartsTypeList.indexOf('minute');\n            var hourMinuteDelimiter = formatParts[(hourIndex + minuteIndex) / 2].value;\n            var hourValue = leftPad(formatParts[hourIndex].value);\n            var minuteValue = leftPad(formatParts[minuteIndex].value);\n            var showSeconds = formatString.indexOf(\"ss\") >= 0;\n            var secondValue = showSeconds ? leftPad(formatParts[formatPartsTypeList.indexOf('second')].value) : \"\";\n            var dayPeriod = formatOptions['hour12'] === true ? formatParts[formatPartsTypeList.indexOf('dayperiod')].value : \"\";\n            return hourValue +\n                   hourMinuteDelimiter +\n                   minuteValue +\n                   (showSeconds ? hourMinuteDelimiter + secondValue : \"\") +\n                   (showSeconds && fractionalSecondsString.length > 0 ? \".\" + fractionalSecondsString : \"\") +\n                   (dayPeriod !== \"\" ? \" \" + dayPeriod : \"\");\n        }\n\n        function getFormattedDateTimeString(date, formatString) {\n            var locale = navigator.language || navigator.browserLanguage || navigator.languages[0];\n            var formatOptions = getFormatterOptions(formatString);\n            var dateString = getFormattedDateString(date, formatString, formatOptions, locale);\n            var timeString = getFormattedTimeString(date, formatString, formatOptions, locale);\n            return timeString + (dateString !== \"\" && timeString !== \"\" ? \"<br>\" : \"\") + dateString;\n        }\n\n        function getDefaultDateTimeString(gregorianDate, showMilliseconds, ms) {\n            var msString = showMilliseconds ? '.' + padNTimes(ms, '0', 3) : '';\n            var time = Globalize.format(gregorianDate, \"T\", formatLanguage());\n            time = addMilliseconds(time, msString) + '<br>' + Globalize.format(gregorianDate, \"d\", formatLanguage());\n            return time;\n        }\n\n        function toAbsoluteTimeStr(date, showMilliseconds, formatString, timeEpoch) {\n            var unixToAbsoluteEpochDiff = 62135596800000,\n                minDateValue = -8640000000000000,\n                d = date.valueOf(),\n                ms = Math.floor(d % 1000);\n\n            if (ms < 0) {\n                ms = 1000 + ms;\n            }\n\n            if (date < minDateValue + unixToAbsoluteEpochDiff) {\n                date = minDateValue + unixToAbsoluteEpochDiff;\n            }\n\n            var gregorianDate = makeUtcWrapper(new Date(date.valueOf() + timeEpoch)).date;\n\n            var time;\n            if (formatString !== \"\") {\n                try {\n                    time = getFormattedDateTimeString(gregorianDate, formatString);\n                }\n                catch(err) {\n                    time = getDefaultDateTimeString(gregorianDate, showMilliseconds, ms);\n                }\n            } else {\n                time = getDefaultDateTimeString(gregorianDate, showMilliseconds, ms);\n            }\n\n            return time;\n        }\n\n        function toRelativeTimeStr(date, showMilliseconds, formatString) {\n            var result = '';\n\n            var dateValue = date.valueOf(),\n                d = dateValue - (axis.valueOfFirstData === undefined ? 0 : axis.valueOfFirstData);\n\n            if (d < 0) {\n                d = -d;\n                result += '-';\n            }\n            var dateInSeconds = Math.floor(d / 1000);\n            var milliseconds = Math.floor(d % 1000);\n            var seconds = dateInSeconds % 60;\n            var dateInMinutes = Math.floor(dateInSeconds / 60);\n            var minutes = dateInMinutes % 60;\n            var dateInHours = Math.floor(dateInMinutes / 60);\n            var hours = dateInHours % 24;\n            var days = Math.floor(dateInHours / 24);\n            var showSeconds = formatString === \"\" || formatString.indexOf(\"ss\") >= 0;\n\n            if (days && formatString === \"\") {\n                result += days + '.';\n            }\n\n            result += leftPad(hours) + ':';\n            result += leftPad(minutes);\n            if (showSeconds) {\n                result += (\":\" + leftPad(seconds));\n                var fractionalSecondsString = getFractionalSecondsString(milliseconds, formatString, showMilliseconds);\n                result += (showMilliseconds || fractionalSecondsString.length > 0) ? '.' + fractionalSecondsString : \"\";\n            }\n\n            return result;\n        }\n\n        var r = [];\n        var escape = false;\n\n        if (!monthNames) {\n            monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n        }\n\n        if (!dayNames) {\n            dayNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n        }\n\n        for (var i = 0; i < fmt.length; ++i) {\n            var c = fmt.charAt(i),\n                localDateValue = d.date || d.getDate();\n            if (escape) {\n                var timeFormatStartIndex = fmt.indexOf('<');\n                var timeFormatEndIndex = fmt.indexOf('>');\n                var timeFormat = timeFormatStartIndex > 0 ? fmt.substring(timeFormatStartIndex + 1, timeFormatEndIndex) : \"\";\n                if (timeFormatStartIndex > 0) {\n                    i += (timeFormat.length + 2);\n                }\n\n                switch (c) {\n                    case 'r': c = toRelativeTimeStr(localDateValue, showMilliseconds, timeFormat); break;\n                    case 'A': c = toAbsoluteTimeStr(localDateValue, showMilliseconds, timeFormat, axis.options.timeEpoch); break;\n                }\n                r.push(c);\n                escape = false;\n            } else {\n                if (c === \"%\") {\n                    escape = true;\n                } else {\n                    r.push(c);\n                }\n            }\n        }\n\n        return r.join(\"\");\n    }\n\n    // To have a consistent view of time-based data independent of which time\n    // zone the client happens to be in we need a date-like object independent\n    // of time zones.  This is done through a wrapper that only calls the UTC\n    // versions of the accessor methods.\n\n    function makeUtcWrapper(d) {\n        function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {\n            sourceObj[sourceMethod] = function() {\n                return targetObj[targetMethod].apply(targetObj, arguments);\n            };\n        }\n\n        var utc = {\n            date: d\n        };\n\n        // support strftime, if found\n        if (d.strftime !== undefined) {\n            addProxyMethod(utc, \"strftime\", d, \"strftime\");\n        }\n\n        addProxyMethod(utc, \"getTime\", d, \"getTime\");\n        addProxyMethod(utc, \"setTime\", d, \"setTime\");\n\n        var props = [\"Date\", \"Day\", \"FullYear\", \"Hours\", \"Milliseconds\", \"Minutes\", \"Month\", \"Seconds\"];\n\n        for (var p = 0; p < props.length; p++) {\n            addProxyMethod(utc, \"get\" + props[p], d, \"getUTC\" + props[p]);\n            addProxyMethod(utc, \"set\" + props[p], d, \"setUTC\" + props[p]);\n        }\n\n        return utc;\n    }\n\n    // select time zone strategy.  This returns a date-like object tied to the\n    // desired timezone\n    function dateGenerator(ts, opts) {\n        var maxDateValue = 8640000000000000;\n\n        ts *= 1000;\n\n        if (ts > maxDateValue) {\n            ts = maxDateValue;\n        } else if (ts < -maxDateValue) {\n            ts = -maxDateValue;\n        }\n\n        if (opts.timezone === \"browser\") {\n            return new Date(ts);\n        } else if (!opts.timezone || opts.timezone === \"utc\") {\n            return makeUtcWrapper(new Date(ts));\n        } else if (typeof timezoneJS !== \"undefined\" && typeof timezoneJS.Date !== \"undefined\") {\n            var d = new timezoneJS.Date();\n            // timezone-js is fickle, so be sure to set the time zone before\n            // setting the time.\n            d.setTimezone(opts.timezone);\n            d.setTime(ts);\n            return d;\n        } else {\n            return makeUtcWrapper(new Date(ts));\n        }\n    }\n\n    // map of app. size of time units in milliseconds\n    var timeUnitSize = {\n        \"millisecond\": 0.001,\n        \"second\": 1,\n        \"minute\": 60,\n        \"hour\": 60 * 60,\n        \"day\": 24 * 60 * 60,\n        \"month\": 30 * 24 * 60 * 60,\n        \"quarter\": 3 * 30 * 24 * 60 * 60,\n        \"year\": 365.2425 * 24 * 60 * 60\n    };\n\n    // the allowed tick sizes, after 1 year we use\n    // an integer algorithm\n\n    var baseSpec = [\n        [1, \"millisecond\"], [2, \"millisecond\"], [5, \"millisecond\"], [10, \"millisecond\"],\n        [25, \"millisecond\"], [50, \"millisecond\"], [100, \"millisecond\"], [250, \"millisecond\"], [500, \"millisecond\"],\n        [1, \"second\"], [2, \"second\"], [5, \"second\"], [10, \"second\"],\n        [30, \"second\"],\n        [1, \"minute\"], [2, \"minute\"], [5, \"minute\"], [10, \"minute\"],\n        [30, \"minute\"],\n        [1, \"hour\"], [2, \"hour\"], [4, \"hour\"],\n        [8, \"hour\"], [12, \"hour\"],\n        [1, \"day\"], [2, \"day\"], [3, \"day\"],\n        [0.25, \"month\"], [0.5, \"month\"], [1, \"month\"],\n        [2, \"month\"]\n    ];\n\n    // we don't know which variant(s) we'll need yet, but generating both is\n    // cheap\n\n    var specMonths = baseSpec.concat([[3, \"month\"], [6, \"month\"],\n        [1, \"year\"]]);\n    var specQuarters = baseSpec.concat([[1, \"quarter\"], [2, \"quarter\"],\n        [1, \"year\"]]);\n\n    //function used for relative time axis to compute the first data point from which the values are starting\n    function updateAxisFirstData(plot, axis) {\n        var plotData = plot.getData();\n        if (plotData.length > 0 && (plotData[0].data.length > 0 || plotData[0].datapoints.points.length > 0)) {\n            var i, firstPlotData, minFirstPlotData, datapoints = plotData[0].datapoints;\n            if (datapoints.points.length !== 0) {\n                if (plotData[0].xaxis === axis || plotData[0].yaxis === axis) {\n                    minFirstPlotData = axis.direction === \"x\" ? datapoints.points[0] : datapoints.points[1];\n                } else { minFirstPlotData = axis.max; }\n            } else { minFirstPlotData = axis.min; }\n\n            for (i = 1; i < plotData.length; i++) {\n                datapoints = plotData[i].datapoints;\n                if (plotData[i].xaxis === axis || plotData[i].yaxis === axis) {\n                    firstPlotData = axis.direction === \"x\" ? datapoints.points[0] : datapoints.points[1];\n                    if (minFirstPlotData > firstPlotData) {\n                        minFirstPlotData = firstPlotData;\n                    }\n                }\n            }\n\n            axis.valueOfFirstData = minFirstPlotData * 1000;\n        }\n    }\n\n    function init(plot) {\n        plot.hooks.processOptions.push(function (plot) {\n            $.each(plot.getAxes(), function(axisName, axis) {\n                var opts = axis.options;\n                if (opts.format === \"time\") {\n                    axis.tickGenerator = function(axis) {\n                        var ticks = [],\n                            d = dateGenerator(axis.min, opts),\n                            minSize = 0;\n\n                        if (axis.valueOfFirstData === undefined) {\n                            updateAxisFirstData(plot, axis);\n                        }\n\n                        // make quarter use a possibility if quarters are\n                        // mentioned in either of these options\n                        var spec = (opts.tickSize && opts.tickSize[1] ===\n                            \"quarter\") ||\n                            (opts.minTickSize && opts.minTickSize[1] ===\n                            \"quarter\") ? specQuarters : specMonths;\n\n                        if (opts.minTickSize !== null && opts.minTickSize !== undefined) {\n                            if (typeof opts.tickSize === \"number\") {\n                                minSize = opts.tickSize;\n                            } else {\n                                minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];\n                            }\n                        }\n\n                        var delta = axis.delta * 2;\n                        for (var i = 0; i < spec.length - 1; ++i) {\n                            if (delta < (spec[i][0] * timeUnitSize[spec[i][1]] +\n                                spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2 &&\n                                spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {\n                                break;\n                            }\n                        }\n\n                        var size = spec[i][0];\n                        var unit = spec[i][1];\n                        // special-case the possibility of several years\n                        if (unit === \"year\") {\n                            // if given a minTickSize in years, just use it,\n                            // ensuring that it's an integer\n\n                            if (opts.minTickSize !== null && opts.minTickSize !== undefined && opts.minTickSize[1] === \"year\") {\n                                size = Math.floor(opts.minTickSize[0]);\n                            } else {\n                                var magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));\n                                var norm = (axis.delta / timeUnitSize.year) / magn;\n\n                                if (norm < 1.5) {\n                                    size = 1;\n                                } else if (norm < 3) {\n                                    size = 2;\n                                } else if (norm < 7.5) {\n                                    size = 5;\n                                } else {\n                                    size = 10;\n                                }\n\n                                size *= magn;\n                            }\n\n                            // minimum size for years is 1\n\n                            if (size < 1) {\n                                size = 1;\n                            }\n                        }\n\n                        axis.tickSize = opts.tickSize || [size, unit];\n                        var tickSize = axis.tickSize[0];\n                        unit = axis.tickSize[1];\n\n                        var step = tickSize * timeUnitSize[unit];\n\n                        if (unit === \"millisecond\") {\n                            d.setMilliseconds(floorInBase(d.getMilliseconds(), tickSize));\n                        } else if (unit === \"second\") {\n                            d.setSeconds(floorInBase(d.getSeconds(), tickSize));\n                        } else if (unit === \"minute\") {\n                            d.setMinutes(floorInBase(d.getMinutes(), tickSize));\n                        } else if (unit === \"hour\") {\n                            d.setHours(floorInBase(d.getHours(), tickSize));\n                        } else if (unit === \"month\") {\n                            d.setMonth(floorInBase(d.getMonth(), tickSize));\n                        } else if (unit === \"quarter\") {\n                            d.setMonth(3 * floorInBase(d.getMonth() / 3,\n                                tickSize));\n                        } else if (unit === \"year\") {\n                            d.setFullYear(floorInBase(d.getFullYear(), tickSize));\n                        }\n\n                        // reset smaller components\n\n                        if (step >= timeUnitSize.second) {\n                            d.setMilliseconds(0);\n                        }\n\n                        if (step >= timeUnitSize.minute) {\n                            d.setSeconds(0);\n                        }\n                        if (step >= timeUnitSize.hour) {\n                            d.setMinutes(0);\n                        }\n                        if (step >= timeUnitSize.day) {\n                            d.setHours(0);\n                        }\n                        if (step >= timeUnitSize.day * 4) {\n                            d.setDate(1);\n                        }\n                        if (step >= timeUnitSize.month * 2) {\n                            d.setMonth(floorInBase(d.getMonth(), 3));\n                        }\n                        if (step >= timeUnitSize.quarter * 2) {\n                            d.setMonth(floorInBase(d.getMonth(), 6));\n                        }\n                        if (step >= timeUnitSize.year) {\n                            d.setMonth(0);\n                        }\n\n                        var carry = 0;\n                        var v = Number.NaN;\n                        var v1000;\n                        var prev;\n                        do {\n                            prev = v;\n                            v1000 = d.getTime();\n                            v = v1000 / 1000;\n                            ticks.push(v);\n\n                            if (unit === \"month\" || unit === \"quarter\") {\n                                if (tickSize < 1) {\n                                    // a bit complicated - we'll divide the\n                                    // month/quarter up but we need to take\n                                    // care of fractions so we don't end up in\n                                    // the middle of a day\n                                    d.setDate(1);\n                                    var start = d.getTime();\n                                    d.setMonth(d.getMonth() +\n                                        (unit === \"quarter\" ? 3 : 1));\n                                    var end = d.getTime();\n                                    d.setTime((v + carry * timeUnitSize.hour + (end - start) * tickSize));\n                                    carry = d.getHours();\n                                    d.setHours(0);\n                                } else {\n                                    d.setMonth(d.getMonth() +\n                                        tickSize * (unit === \"quarter\" ? 3 : 1));\n                                }\n                            } else if (unit === \"year\") {\n                                d.setFullYear(d.getFullYear() + tickSize);\n                            } else {\n                                d.setTime((v + step) * 1000);\n                            }\n                        } while (v < axis.max && v !== prev);\n\n                        return ticks;\n                    };\n\n                    axis.tickFormatter = function (v, axis) {\n                        var d = dateGenerator(v, axis.options);\n                        // first check global format\n                        if (opts.timeformat !== null && opts.timeformat !== undefined) {\n                            return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames, axis.tickSize[1] === 'millisecond', axis);\n                        }\n                    };\n                }\n            });\n        });\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'time',\n        version: '1.0'\n    });\n\n    // Time-axis support used to be in Flot core, which exposed the\n    // formatDate function on the plot object.  Various plugins depend\n    // on the function, so we need to re-expose it here.\n\n    $.plot.formatDate = formatDate;\n    $.plot.dateGenerator = dateGenerator;\n})(jQuery);\n","/*\nAxis label plugin for engineering-flot\n\nDerived from:\nAxis Labels Plugin for flot.\nhttp://github.com/markrcote/flot-axislabels\n\nOriginal code is Copyright (c) 2010 Xuan Luo.\nOriginal code was released under the GPLv3 license by Xuan Luo, September 2010.\nOriginal code was rereleased under the MIT license by Xuan Luo, April 2012.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n(function($) {\n    \"use strict\";\n\n    var options = {\n        axisLabels: {\n            show: true\n        }\n    };\n\n    function AxisLabel(axisName, position, padding, placeholder, axisLabel, surface) {\n        this.axisName = axisName;\n        this.position = position;\n        this.padding = padding;\n        this.placeholder = placeholder;\n        this.axisLabel = axisLabel;\n        this.surface = surface;\n        this.width = 0;\n        this.height = 0;\n        this.elem = null;\n    }\n\n    AxisLabel.prototype.calculateSize = function() {\n        var axisId = this.axisName + 'Label',\n            layerId = axisId + 'Layer',\n            className = axisId + ' axisLabels';\n\n        var info = this.surface.getTextInfo(layerId, this.axisLabel, className);\n        this.labelWidth = info.width;\n        this.labelHeight = info.height;\n\n        if (this.position === 'left' || this.position === 'right') {\n            this.width = this.labelHeight + this.padding;\n            this.height = 0;\n        } else {\n            this.width = 0;\n            this.height = this.labelHeight + this.padding;\n        }\n    };\n\n    AxisLabel.prototype.transforms = function(degrees, x, y, svgLayer) {\n        var transforms = [], translate, rotate;\n        if (x !== 0 || y !== 0) {\n            translate = svgLayer.createSVGTransform();\n            translate.setTranslate(x, y);\n            transforms.push(translate);\n        }\n        if (degrees !== 0) {\n            rotate = svgLayer.createSVGTransform();\n            var centerX = Math.round(this.labelWidth / 2),\n                centerY = 0;\n            rotate.setRotate(degrees, centerX, centerY);\n            transforms.push(rotate);\n        }\n\n        return transforms;\n    };\n\n    AxisLabel.prototype.calculateOffsets = function(box) {\n        var offsets = {\n            x: 0,\n            y: 0,\n            degrees: 0\n        };\n        if (this.position === 'bottom') {\n            offsets.x = box.left + box.width / 2 - this.labelWidth / 2;\n            offsets.y = box.top + box.height - this.labelHeight;\n        } else if (this.position === 'top') {\n            offsets.x = box.left + box.width / 2 - this.labelWidth / 2;\n            offsets.y = box.top;\n        } else if (this.position === 'left') {\n            offsets.degrees = -90;\n            offsets.x = box.left - this.labelWidth / 2;\n            offsets.y = box.height / 2 + box.top;\n        } else if (this.position === 'right') {\n            offsets.degrees = 90;\n            offsets.x = box.left + box.width - this.labelWidth / 2;\n            offsets.y = box.height / 2 + box.top;\n        }\n        offsets.x = Math.round(offsets.x);\n        offsets.y = Math.round(offsets.y);\n\n        return offsets;\n    };\n\n    AxisLabel.prototype.cleanup = function() {\n        var axisId = this.axisName + 'Label',\n            layerId = axisId + 'Layer',\n            className = axisId + ' axisLabels';\n        this.surface.removeText(layerId, 0, 0, this.axisLabel, className);\n    };\n\n    AxisLabel.prototype.draw = function(box) {\n        var axisId = this.axisName + 'Label',\n            layerId = axisId + 'Layer',\n            className = axisId + ' axisLabels',\n            offsets = this.calculateOffsets(box),\n            style = {\n                position: 'absolute',\n                bottom: '',\n                right: '',\n                display: 'inline-block',\n                'white-space': 'nowrap'\n            };\n\n        var layer = this.surface.getSVGLayer(layerId);\n        var transforms = this.transforms(offsets.degrees, offsets.x, offsets.y, layer.parentNode);\n\n        this.surface.addText(layerId, 0, 0, this.axisLabel, className, undefined, undefined, undefined, undefined, transforms);\n        this.surface.render();\n        Object.keys(style).forEach(function(key) {\n            layer.style[key] = style[key];\n        });\n    };\n\n    function init(plot) {\n        plot.hooks.processOptions.push(function(plot, options) {\n            if (!options.axisLabels.show) {\n                return;\n            }\n\n            var axisLabels = {};\n            var defaultPadding = 2; // padding between axis and tick labels\n\n            plot.hooks.axisReserveSpace.push(function(plot, axis) {\n                var opts = axis.options;\n                var axisName = axis.direction + axis.n;\n\n                axis.labelHeight += axis.boxPosition.centerY;\n                axis.labelWidth += axis.boxPosition.centerX;\n\n                if (!opts || !opts.axisLabel || !axis.show) {\n                    return;\n                }\n\n                var padding = opts.axisLabelPadding === undefined\n                    ? defaultPadding\n                    : opts.axisLabelPadding;\n\n                var axisLabel = axisLabels[axisName];\n                if (!axisLabel) {\n                    axisLabel = new AxisLabel(axisName,\n                        opts.position, padding,\n                        plot.getPlaceholder()[0], opts.axisLabel, plot.getSurface());\n                    axisLabels[axisName] = axisLabel;\n                }\n\n                axisLabel.calculateSize();\n\n                // Incrementing the sizes of the tick labels.\n                axis.labelHeight += axisLabel.height;\n                axis.labelWidth += axisLabel.width;\n            });\n\n            // TODO - use the drawAxis hook\n            plot.hooks.draw.push(function(plot, ctx) {\n                $.each(plot.getAxes(), function(flotAxisName, axis) {\n                    var opts = axis.options;\n                    if (!opts || !opts.axisLabel || !axis.show) {\n                        return;\n                    }\n\n                    var axisName = axis.direction + axis.n;\n                    axisLabels[axisName].draw(axis.box);\n                });\n            });\n\n            plot.hooks.shutdown.push(function(plot, eventHolder) {\n                for (var axisName in axisLabels) {\n                    axisLabels[axisName].cleanup();\n                }\n            });\n        });\n    };\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'axisLabels',\n        version: '3.0'\n    });\n})(jQuery);\n","/* Flot plugin for selecting regions of a plot.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe plugin supports these options:\n\nselection: {\n    mode: null or \"x\" or \"y\" or \"xy\" or \"smart\",\n    color: color,\n    shape: \"round\" or \"miter\" or \"bevel\",\n    minSize: number of pixels\n}\n\nSelection support is enabled by setting the mode to one of \"x\", \"y\" or \"xy\".\nIn \"x\" mode, the user will only be able to specify the x range, similarly for\n\"y\" mode. For \"xy\", the selection becomes a rectangle where both ranges can be\nspecified. \"color\" is color of the selection (if you need to change the color\nlater on, you can get to it with plot.getOptions().selection.color). \"shape\"\nis the shape of the corners of the selection.\n\n\"minSize\" is the minimum size a selection can be in pixels. This value can\nbe customized to determine the smallest size a selection can be and still\nhave the selection rectangle be displayed. When customizing this value, the\nfact that it refers to pixels, not axis units must be taken into account.\nThus, for example, if there is a bar graph in time mode with BarWidth set to 1\nminute, setting \"minSize\" to 1 will not make the minimum selection size 1\nminute, but rather 1 pixel. Note also that setting \"minSize\" to 0 will prevent\n\"plotunselected\" events from being fired when the user clicks the mouse without\ndragging.\n\nWhen selection support is enabled, a \"plotselected\" event will be emitted on\nthe DOM element you passed into the plot function. The event handler gets a\nparameter with the ranges selected on the axes, like this:\n\n    placeholder.bind( \"plotselected\", function( event, ranges ) {\n        alert(\"You selected \" + ranges.xaxis.from + \" to \" + ranges.xaxis.to)\n        // similar for yaxis - with multiple axes, the extra ones are in\n        // x2axis, x3axis, ...\n    });\n\nThe \"plotselected\" event is only fired when the user has finished making the\nselection. A \"plotselecting\" event is fired during the process with the same\nparameters as the \"plotselected\" event, in case you want to know what's\nhappening while it's happening,\n\nA \"plotunselected\" event with no arguments is emitted when the user clicks the\nmouse to remove the selection. As stated above, setting \"minSize\" to 0 will\ndestroy this behavior.\n\nThe plugin allso adds the following methods to the plot object:\n\n- setSelection( ranges, preventEvent )\n\n  Set the selection rectangle. The passed in ranges is on the same form as\n  returned in the \"plotselected\" event. If the selection mode is \"x\", you\n  should put in either an xaxis range, if the mode is \"y\" you need to put in\n  an yaxis range and both xaxis and yaxis if the selection mode is \"xy\", like\n  this:\n\n    setSelection({ xaxis: { from: 0, to: 10 }, yaxis: { from: 40, to: 60 } });\n\n  setSelection will trigger the \"plotselected\" event when called. If you don't\n  want that to happen, e.g. if you're inside a \"plotselected\" handler, pass\n  true as the second parameter. If you are using multiple axes, you can\n  specify the ranges on any of those, e.g. as x2axis/x3axis/... instead of\n  xaxis, the plugin picks the first one it sees.\n\n- clearSelection( preventEvent )\n\n  Clear the selection rectangle. Pass in true to avoid getting a\n  \"plotunselected\" event.\n\n- getSelection()\n\n  Returns the current selection in the same format as the \"plotselected\"\n  event. If there's currently no selection, the function returns null.\n\n*/\n\n(function ($) {\n    function init(plot) {\n        var selection = {\n            first: {x: -1, y: -1},\n            second: {x: -1, y: -1},\n            show: false,\n            currentMode: 'xy',\n            active: false\n        };\n\n        var SNAPPING_CONSTANT = $.plot.uiConstants.SNAPPING_CONSTANT;\n\n        // FIXME: The drag handling implemented here should be\n        // abstracted out, there's some similar code from a library in\n        // the navigation plugin, this should be massaged a bit to fit\n        // the Flot cases here better and reused. Doing this would\n        // make this plugin much slimmer.\n        var savedhandlers = {};\n\n        var mouseUpHandler = null;\n\n        function onMouseMove(e) {\n            if (selection.active) {\n                updateSelection(e);\n\n                plot.getPlaceholder().trigger(\"plotselecting\", [ getSelection() ]);\n            }\n        }\n\n        function onMouseDown(e) {\n            // only accept left-click\n            if (e.which !== 1) return;\n\n            // cancel out any text selections\n            document.body.focus();\n\n            // prevent text selection and drag in old-school browsers\n            if (document.onselectstart !== undefined && savedhandlers.onselectstart == null) {\n                savedhandlers.onselectstart = document.onselectstart;\n                document.onselectstart = function () { return false; };\n            }\n            if (document.ondrag !== undefined && savedhandlers.ondrag == null) {\n                savedhandlers.ondrag = document.ondrag;\n                document.ondrag = function () { return false; };\n            }\n\n            setSelectionPos(selection.first, e);\n\n            selection.active = true;\n\n            // this is a bit silly, but we have to use a closure to be\n            // able to whack the same handler again\n            mouseUpHandler = function (e) { onMouseUp(e); };\n\n            $(document).one(\"mouseup\", mouseUpHandler);\n        }\n\n        function onMouseUp(e) {\n            mouseUpHandler = null;\n\n            // revert drag stuff for old-school browsers\n            if (document.onselectstart !== undefined) {\n                document.onselectstart = savedhandlers.onselectstart;\n            }\n\n            if (document.ondrag !== undefined) {\n                document.ondrag = savedhandlers.ondrag;\n            }\n\n            // no more dragging\n            selection.active = false;\n            updateSelection(e);\n\n            if (selectionIsSane()) {\n                triggerSelectedEvent();\n            } else {\n                // this counts as a clear\n                plot.getPlaceholder().trigger(\"plotunselected\", [ ]);\n                plot.getPlaceholder().trigger(\"plotselecting\", [ null ]);\n            }\n\n            return false;\n        }\n\n        function getSelection() {\n            if (!selectionIsSane()) return null;\n\n            if (!selection.show) return null;\n\n            var r = {},\n                c1 = {x: selection.first.x, y: selection.first.y},\n                c2 = {x: selection.second.x, y: selection.second.y};\n\n            if (selectionDirection(plot) === 'x') {\n                c1.y = 0;\n                c2.y = plot.height();\n            }\n\n            if (selectionDirection(plot) === 'y') {\n                c1.x = 0;\n                c2.x = plot.width();\n            }\n\n            $.each(plot.getAxes(), function (name, axis) {\n                if (axis.used) {\n                    var p1 = axis.c2p(c1[axis.direction]), p2 = axis.c2p(c2[axis.direction]);\n                    r[name] = { from: Math.min(p1, p2), to: Math.max(p1, p2) };\n                }\n            });\n            return r;\n        }\n\n        function triggerSelectedEvent() {\n            var r = getSelection();\n\n            plot.getPlaceholder().trigger(\"plotselected\", [ r ]);\n\n            // backwards-compat stuff, to be removed in future\n            if (r.xaxis && r.yaxis) {\n                plot.getPlaceholder().trigger(\"selected\", [ { x1: r.xaxis.from, y1: r.yaxis.from, x2: r.xaxis.to, y2: r.yaxis.to } ]);\n            }\n        }\n\n        function clamp(min, value, max) {\n            return value < min ? min : (value > max ? max : value);\n        }\n\n        function selectionDirection(plot) {\n            var o = plot.getOptions();\n\n            if (o.selection.mode === 'smart') {\n                return selection.currentMode;\n            } else {\n                return o.selection.mode;\n            }\n        }\n\n        function updateMode(pos) {\n            if (selection.first) {\n                var delta = {\n                    x: pos.x - selection.first.x,\n                    y: pos.y - selection.first.y\n                };\n\n                if (Math.abs(delta.x) < SNAPPING_CONSTANT) {\n                    selection.currentMode = 'y';\n                } else if (Math.abs(delta.y) < SNAPPING_CONSTANT) {\n                    selection.currentMode = 'x';\n                } else {\n                    selection.currentMode = 'xy';\n                }\n            }\n        }\n\n        function setSelectionPos(pos, e) {\n            var offset = plot.getPlaceholder().offset();\n            var plotOffset = plot.getPlotOffset();\n            pos.x = clamp(0, e.pageX - offset.left - plotOffset.left, plot.width());\n            pos.y = clamp(0, e.pageY - offset.top - plotOffset.top, plot.height());\n\n            if (pos !== selection.first) updateMode(pos);\n\n            if (selectionDirection(plot) === \"y\") {\n                pos.x = pos === selection.first ? 0 : plot.width();\n            }\n\n            if (selectionDirection(plot) === \"x\") {\n                pos.y = pos === selection.first ? 0 : plot.height();\n            }\n        }\n\n        function updateSelection(pos) {\n            if (pos.pageX == null) return;\n\n            setSelectionPos(selection.second, pos);\n            if (selectionIsSane()) {\n                selection.show = true;\n                plot.triggerRedrawOverlay();\n            } else clearSelection(true);\n        }\n\n        function clearSelection(preventEvent) {\n            if (selection.show) {\n                selection.show = false;\n                selection.currentMode = '';\n                plot.triggerRedrawOverlay();\n                if (!preventEvent) {\n                    plot.getPlaceholder().trigger(\"plotunselected\", [ ]);\n                }\n            }\n        }\n\n        // function taken from markings support in Flot\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = plot.getAxes();\n\n            for (var k in axes) {\n                axis = axes[k];\n                if (axis.direction === coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n === 1) {\n                        // support x1axis as xaxis\n                        key = coord + \"axis\";\n                    }\n\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord === \"x\" ? plot.getXAxes()[0] : plot.getYAxes()[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return { from: from, to: to, axis: axis };\n        }\n\n        function setSelection(ranges, preventEvent) {\n            var range;\n\n            if (selectionDirection(plot) === \"y\") {\n                selection.first.x = 0;\n                selection.second.x = plot.width();\n            } else {\n                range = extractRange(ranges, \"x\");\n                selection.first.x = range.axis.p2c(range.from);\n                selection.second.x = range.axis.p2c(range.to);\n            }\n\n            if (selectionDirection(plot) === \"x\") {\n                selection.first.y = 0;\n                selection.second.y = plot.height();\n            } else {\n                range = extractRange(ranges, \"y\");\n                selection.first.y = range.axis.p2c(range.from);\n                selection.second.y = range.axis.p2c(range.to);\n            }\n\n            selection.show = true;\n            plot.triggerRedrawOverlay();\n            if (!preventEvent && selectionIsSane()) {\n                triggerSelectedEvent();\n            }\n        }\n\n        function selectionIsSane() {\n            var minSize = plot.getOptions().selection.minSize;\n            return Math.abs(selection.second.x - selection.first.x) >= minSize &&\n                Math.abs(selection.second.y - selection.first.y) >= minSize;\n        }\n\n        plot.clearSelection = clearSelection;\n        plot.setSelection = setSelection;\n        plot.getSelection = getSelection;\n\n        plot.hooks.bindEvents.push(function(plot, eventHolder) {\n            var o = plot.getOptions();\n            if (o.selection.mode != null) {\n                eventHolder.mousemove(onMouseMove);\n                eventHolder.mousedown(onMouseDown);\n            }\n        });\n\n        function drawSelectionDecorations(ctx, x, y, w, h, oX, oY, mode) {\n            var spacing = 3;\n            var fullEarWidth = 15;\n            var earWidth = Math.max(0, Math.min(fullEarWidth, w / 2 - 2, h / 2 - 2));\n            ctx.fillStyle = '#ffffff';\n\n            if (mode === 'xy') {\n                ctx.beginPath();\n                ctx.moveTo(x, y + earWidth);\n                ctx.lineTo(x - 3, y + earWidth);\n                ctx.lineTo(x - 3, y - 3);\n                ctx.lineTo(x + earWidth, y - 3);\n                ctx.lineTo(x + earWidth, y);\n                ctx.lineTo(x, y);\n                ctx.closePath();\n\n                ctx.moveTo(x, y + h - earWidth);\n                ctx.lineTo(x - 3, y + h - earWidth);\n                ctx.lineTo(x - 3, y + h + 3);\n                ctx.lineTo(x + earWidth, y + h + 3);\n                ctx.lineTo(x + earWidth, y + h);\n                ctx.lineTo(x, y + h);\n                ctx.closePath();\n\n                ctx.moveTo(x + w, y + earWidth);\n                ctx.lineTo(x + w + 3, y + earWidth);\n                ctx.lineTo(x + w + 3, y - 3);\n                ctx.lineTo(x + w - earWidth, y - 3);\n                ctx.lineTo(x + w - earWidth, y);\n                ctx.lineTo(x + w, y);\n                ctx.closePath();\n\n                ctx.moveTo(x + w, y + h - earWidth);\n                ctx.lineTo(x + w + 3, y + h - earWidth);\n                ctx.lineTo(x + w + 3, y + h + 3);\n                ctx.lineTo(x + w - earWidth, y + h + 3);\n                ctx.lineTo(x + w - earWidth, y + h);\n                ctx.lineTo(x + w, y + h);\n                ctx.closePath();\n\n                ctx.stroke();\n                ctx.fill();\n            }\n\n            x = oX;\n            y = oY;\n\n            if (mode === 'x') {\n                ctx.beginPath();\n                ctx.moveTo(x, y + fullEarWidth);\n                ctx.lineTo(x, y - fullEarWidth);\n                ctx.lineTo(x - spacing, y - fullEarWidth);\n                ctx.lineTo(x - spacing, y + fullEarWidth);\n                ctx.closePath();\n\n                ctx.moveTo(x + w, y + fullEarWidth);\n                ctx.lineTo(x + w, y - fullEarWidth);\n                ctx.lineTo(x + w + spacing, y - fullEarWidth);\n                ctx.lineTo(x + w + spacing, y + fullEarWidth);\n                ctx.closePath();\n                ctx.stroke();\n                ctx.fill();\n            }\n\n            if (mode === 'y') {\n                ctx.beginPath();\n\n                ctx.moveTo(x - fullEarWidth, y);\n                ctx.lineTo(x + fullEarWidth, y);\n                ctx.lineTo(x + fullEarWidth, y - spacing);\n                ctx.lineTo(x - fullEarWidth, y - spacing);\n                ctx.closePath();\n\n                ctx.moveTo(x - fullEarWidth, y + h);\n                ctx.lineTo(x + fullEarWidth, y + h);\n                ctx.lineTo(x + fullEarWidth, y + h + spacing);\n                ctx.lineTo(x - fullEarWidth, y + h + spacing);\n                ctx.closePath();\n                ctx.stroke();\n                ctx.fill();\n            }\n        }\n\n        plot.hooks.drawOverlay.push(function (plot, ctx) {\n            // draw selection\n            if (selection.show && selectionIsSane()) {\n                var plotOffset = plot.getPlotOffset();\n                var o = plot.getOptions();\n\n                ctx.save();\n                ctx.translate(plotOffset.left, plotOffset.top);\n\n                var c = $.color.parse(o.selection.color);\n\n                ctx.strokeStyle = c.scale('a', 1).toString();\n                ctx.lineWidth = 1;\n                ctx.lineJoin = o.selection.shape;\n                ctx.fillStyle = c.scale('a', 0.4).toString();\n\n                var x = Math.min(selection.first.x, selection.second.x) + 0.5,\n                    oX = x,\n                    y = Math.min(selection.first.y, selection.second.y) + 0.5,\n                    oY = y,\n                    w = Math.abs(selection.second.x - selection.first.x) - 1,\n                    h = Math.abs(selection.second.y - selection.first.y) - 1;\n\n                if (selectionDirection(plot) === 'x') {\n                    h += y;\n                    y = 0;\n                }\n\n                if (selectionDirection(plot) === 'y') {\n                    w += x;\n                    x = 0;\n                }\n\n                ctx.fillRect(0, 0, plot.width(), plot.height());\n                ctx.clearRect(x, y, w, h);\n                drawSelectionDecorations(ctx, x, y, w, h, oX, oY, selectionDirection(plot));\n\n                ctx.restore();\n            }\n        });\n\n        plot.hooks.shutdown.push(function (plot, eventHolder) {\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mousedown\", onMouseDown);\n\n            if (mouseUpHandler) {\n                $(document).unbind(\"mouseup\", mouseUpHandler);\n            }\n        });\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: {\n            selection: {\n                mode: null, // one of null, \"x\", \"y\" or \"xy\"\n                color: \"#888888\",\n                shape: \"round\", // one of \"round\", \"miter\", or \"bevel\"\n                minSize: 5 // minimum number of pixels\n            }\n        },\n        name: 'selection',\n        version: '1.1'\n    });\n})(jQuery);\n","/** ## jquery.flot.composeImages.js\n\nThis plugin is used to expose a function used to overlap several canvases and\nSVGs, for the purpose of creating a snaphot out of them.\n\n### When composeImages is used:\nWhen multiple canvases and SVGs have to be overlapped into a single image\nand their offset on the page, must be preserved.\n\n### Where can be used:\nIn creating a downloadable snapshot of the plots, axes, cursors etc of a graph.\n\n### How it works:\nThe entry point is composeImages function. It expects an array of objects,\nwhich should be either canvases or SVGs (or a mix). It does a prevalidation\nof them, by verifying if they will be usable or not, later in the flow.\nAfter selecting only usable sources, it passes them to getGenerateTempImg\nfunction, which generates temporary images out of them. This function\nexpects that some of the passed sources (canvas or SVG) may still have\nproblems being converted to an image and makes sure the promises system,\nused by composeImages function, moves forward. As an example, SVGs with\nmissing information from header or with unsupported content, may lead to\nfailure in generating the temporary image. Temporary images are required\nmostly on extracting content from SVGs, but this is also where the x/y\noffsets are extracted for each image which will be added. For SVGs in\nparticular, their CSS rules have to be applied.\nAfter all temporary images are generated, they are overlapped using\ngetExecuteImgComposition function. This is where the destination canvas\nis set to the proper dimensions. It is then output by composeImages.\nThis function returns a promise, which can be used to wait for the whole\ncomposition process. It requires to be asynchronous, because this is how\ntemporary images load their data.\n*/\n\n(function($) {\n    \"use strict\";\n    const GENERALFAILURECALLBACKERROR = -100; //simply a negative number\n    const SUCCESSFULIMAGEPREPARATION = 0;\n    const EMPTYARRAYOFIMAGESOURCES = -1;\n    const NEGATIVEIMAGESIZE = -2;\n    var pixelRatio = 1;\n    var browser = $.plot.browser;\n    var getPixelRatio = browser.getPixelRatio;\n\n    function composeImages(canvasOrSvgSources, destinationCanvas) {\n        var validCanvasOrSvgSources = canvasOrSvgSources.filter(isValidSource);\n        pixelRatio = getPixelRatio(destinationCanvas.getContext('2d'));\n\n        var allImgCompositionPromises = validCanvasOrSvgSources.map(function(validCanvasOrSvgSource) {\n            var tempImg = new Image();\n            var currentPromise = new Promise(getGenerateTempImg(tempImg, validCanvasOrSvgSource));\n            return currentPromise;\n        });\n\n        var lastPromise = Promise.all(allImgCompositionPromises).then(getExecuteImgComposition(destinationCanvas), failureCallback);\n        return lastPromise;\n    }\n\n    function isValidSource(canvasOrSvgSource) {\n        var isValidFromCanvas = true;\n        var isValidFromContent = true;\n        if ((canvasOrSvgSource === null) || (canvasOrSvgSource === undefined)) {\n            isValidFromContent = false;\n        } else {\n            if (canvasOrSvgSource.tagName === 'CANVAS') {\n                if ((canvasOrSvgSource.getBoundingClientRect().right === canvasOrSvgSource.getBoundingClientRect().left) ||\n                    (canvasOrSvgSource.getBoundingClientRect().bottom === canvasOrSvgSource.getBoundingClientRect().top)) {\n                    isValidFromCanvas = false;\n                }\n            }\n        }\n        return isValidFromContent && isValidFromCanvas && (window.getComputedStyle(canvasOrSvgSource).visibility === 'visible');\n    }\n\n    function getGenerateTempImg(tempImg, canvasOrSvgSource) {\n        tempImg.sourceDescription = '<info className=\"' + canvasOrSvgSource.className + '\" tagName=\"' + canvasOrSvgSource.tagName + '\" id=\"' + canvasOrSvgSource.id + '\">';\n        tempImg.sourceComponent = canvasOrSvgSource;\n\n        return function doGenerateTempImg(successCallbackFunc, failureCallbackFunc) {\n            tempImg.onload = function(evt) {\n                tempImg.successfullyLoaded = true;\n                successCallbackFunc(tempImg);\n            };\n\n            tempImg.onabort = function(evt) {\n                tempImg.successfullyLoaded = false;\n                console.log('Can\\'t generate temp image from ' + tempImg.sourceDescription + '. It is possible that it is missing some properties or its content is not supported by this browser. Source component:', tempImg.sourceComponent);\n                successCallbackFunc(tempImg); //call successCallback, to allow snapshot of all working images\n            };\n\n            tempImg.onerror = function(evt) {\n                tempImg.successfullyLoaded = false;\n                console.log('Can\\'t generate temp image from ' + tempImg.sourceDescription + '. It is possible that it is missing some properties or its content is not supported by this browser. Source component:', tempImg.sourceComponent);\n                successCallbackFunc(tempImg); //call successCallback, to allow snapshot of all working images\n            };\n\n            generateTempImageFromCanvasOrSvg(canvasOrSvgSource, tempImg);\n        };\n    }\n\n    function getExecuteImgComposition(destinationCanvas) {\n        return function executeImgComposition(tempImgs) {\n            var compositionResult = copyImgsToCanvas(tempImgs, destinationCanvas);\n            return compositionResult;\n        };\n    }\n\n    function copyCanvasToImg(canvas, img) {\n        img.src = canvas.toDataURL('image/png');\n    }\n\n    function getCSSRules(document) {\n        var styleSheets = document.styleSheets,\n            rulesList = [];\n        for (var i = 0; i < styleSheets.length; i++) {\n            // in Chrome, the external CSS files are empty when the page is directly loaded from disk\n            var rules = styleSheets[i].cssRules || [];\n            for (var j = 0; j < rules.length; j++) {\n                var rule = rules[j];\n                rulesList.push(rule.cssText);\n            }\n        }\n        return rulesList;\n    }\n\n    function embedCSSRulesInSVG(rules, svg) {\n        var text = [\n            '<svg class=\"snapshot ' + svg.classList + '\" width=\"' + svg.width.baseVal.value * pixelRatio + '\" height=\"' + svg.height.baseVal.value * pixelRatio + '\" viewBox=\"0 0 ' + svg.width.baseVal.value + ' ' + svg.height.baseVal.value + '\" xmlns=\"http://www.w3.org/2000/svg\">',\n            '<style>',\n            '/* <![CDATA[ */',\n            rules.join('\\n'),\n            '/* ]]> */',\n            '</style>',\n            svg.innerHTML,\n            '</svg>'\n        ].join('\\n');\n        return text;\n    }\n\n    function copySVGToImgMostBrowsers(svg, img) {\n        var rules = getCSSRules(document),\n            source = embedCSSRulesInSVG(rules, svg);\n\n        source = patchSVGSource(source);\n\n        var blob = new Blob([source], {type: \"image/svg+xml;charset=utf-8\"}),\n            domURL = self.URL || self.webkitURL || self,\n            url = domURL.createObjectURL(blob);\n        img.src = url;\n    }\n\n    function copySVGToImgSafari(svg, img) {\n        // Use this method to convert a string buffer array to a binary string.\n        // Do so by breaking up large strings into smaller substrings; this is necessary to avoid the\n        // \"maximum call stack size exceeded\" exception that can happen when calling 'String.fromCharCode.apply'\n        // with a very long array.\n        function buildBinaryString (arrayBuffer) {\n            var binaryString = \"\";\n            const utf8Array = new Uint8Array(arrayBuffer);\n            const blockSize = 16384;\n            for (var i = 0; i < utf8Array.length; i = i + blockSize) {\n                const binarySubString = String.fromCharCode.apply(null, utf8Array.subarray(i, i + blockSize));\n                binaryString = binaryString + binarySubString;\n            }\n            return binaryString;\n        };\n\n        var rules = getCSSRules(document),\n            source = embedCSSRulesInSVG(rules, svg),\n            data,\n            utf8BinaryString;\n\n        source = patchSVGSource(source);\n\n        // Encode the string as UTF-8 and convert it to a binary string. The UTF-8 encoding is required to\n        // capture unicode characters correctly.\n        utf8BinaryString = buildBinaryString(new (TextEncoder || TextEncoderLite)('utf-8').encode(source));\n\n        data = \"data:image/svg+xml;base64,\" + btoa(utf8BinaryString);\n        img.src = data;\n    }\n\n    function patchSVGSource(svgSource) {\n        var source = '';\n        //add name spaces.\n        if (!svgSource.match(/^<svg[^>]+xmlns=\"http:\\/\\/www\\.w3\\.org\\/2000\\/svg\"/)) {\n            source = svgSource.replace(/^<svg/, '<svg xmlns=\"http://www.w3.org/2000/svg\"');\n        }\n        if (!svgSource.match(/^<svg[^>]+\"http:\\/\\/www\\.w3\\.org\\/1999\\/xlink\"/)) {\n            source = svgSource.replace(/^<svg/, '<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\"');\n        }\n\n        //add xml declaration\n        return '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + source;\n    }\n\n    function copySVGToImg(svg, img) {\n        if (browser.isSafari() || browser.isMobileSafari()) {\n            copySVGToImgSafari(svg, img);\n        } else {\n            copySVGToImgMostBrowsers(svg, img);\n        }\n    }\n\n    function adaptDestSizeToZoom(destinationCanvas, sources) {\n        function containsSVGs(source) {\n            return source.srcImgTagName === 'svg';\n        }\n\n        if (sources.find(containsSVGs) !== undefined) {\n            if (pixelRatio < 1) {\n                destinationCanvas.width = destinationCanvas.width * pixelRatio;\n                destinationCanvas.height = destinationCanvas.height * pixelRatio;\n            }\n        }\n    }\n\n    function prepareImagesToBeComposed(sources, destination) {\n        var result = SUCCESSFULIMAGEPREPARATION;\n        if (sources.length === 0) {\n            result = EMPTYARRAYOFIMAGESOURCES; //nothing to do if called without sources\n        } else {\n            var minX = sources[0].genLeft;\n            var minY = sources[0].genTop;\n            var maxX = sources[0].genRight;\n            var maxY = sources[0].genBottom;\n            var i = 0;\n\n            for (i = 1; i < sources.length; i++) {\n                if (minX > sources[i].genLeft) {\n                    minX = sources[i].genLeft;\n                }\n\n                if (minY > sources[i].genTop) {\n                    minY = sources[i].genTop;\n                }\n            }\n\n            for (i = 1; i < sources.length; i++) {\n                if (maxX < sources[i].genRight) {\n                    maxX = sources[i].genRight;\n                }\n\n                if (maxY < sources[i].genBottom) {\n                    maxY = sources[i].genBottom;\n                }\n            }\n\n            if ((maxX - minX <= 0) || (maxY - minY <= 0)) {\n                result = NEGATIVEIMAGESIZE; //this might occur on hidden images\n            } else {\n                destination.width = Math.round(maxX - minX);\n                destination.height = Math.round(maxY - minY);\n\n                for (i = 0; i < sources.length; i++) {\n                    sources[i].xCompOffset = sources[i].genLeft - minX;\n                    sources[i].yCompOffset = sources[i].genTop - minY;\n                }\n\n                adaptDestSizeToZoom(destination, sources);\n            }\n        }\n        return result;\n    }\n\n    function copyImgsToCanvas(sources, destination) {\n        var prepareImagesResult = prepareImagesToBeComposed(sources, destination);\n        if (prepareImagesResult === SUCCESSFULIMAGEPREPARATION) {\n            var destinationCtx = destination.getContext('2d');\n\n            for (var i = 0; i < sources.length; i++) {\n                if (sources[i].successfullyLoaded === true) {\n                    destinationCtx.drawImage(sources[i], sources[i].xCompOffset * pixelRatio, sources[i].yCompOffset * pixelRatio);\n                }\n            }\n        }\n        return prepareImagesResult;\n    }\n\n    function adnotateDestImgWithBoundingClientRect(srcCanvasOrSvg, destImg) {\n        destImg.genLeft = srcCanvasOrSvg.getBoundingClientRect().left;\n        destImg.genTop = srcCanvasOrSvg.getBoundingClientRect().top;\n\n        if (srcCanvasOrSvg.tagName === 'CANVAS') {\n            destImg.genRight = destImg.genLeft + srcCanvasOrSvg.width;\n            destImg.genBottom = destImg.genTop + srcCanvasOrSvg.height;\n        }\n\n        if (srcCanvasOrSvg.tagName === 'svg') {\n            destImg.genRight = srcCanvasOrSvg.getBoundingClientRect().right;\n            destImg.genBottom = srcCanvasOrSvg.getBoundingClientRect().bottom;\n        }\n    }\n\n    function generateTempImageFromCanvasOrSvg(srcCanvasOrSvg, destImg) {\n        if (srcCanvasOrSvg.tagName === 'CANVAS') {\n            copyCanvasToImg(srcCanvasOrSvg, destImg);\n        }\n\n        if (srcCanvasOrSvg.tagName === 'svg') {\n            copySVGToImg(srcCanvasOrSvg, destImg);\n        }\n\n        destImg.srcImgTagName = srcCanvasOrSvg.tagName;\n        adnotateDestImgWithBoundingClientRect(srcCanvasOrSvg, destImg);\n    }\n\n    function failureCallback() {\n        return GENERALFAILURECALLBACKERROR;\n    }\n\n    // used for testing\n    $.plot.composeImages = composeImages;\n\n    function init(plot) {\n        // used to extend the public API of the plot\n        plot.composeImages = composeImages;\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        name: 'composeImages',\n        version: '1.0'\n    });\n})(jQuery);\n","/* Flot plugin for drawing legends.\n\n*/\n\n(function($) {\n    var defaultOptions = {\n        legend: {\n            show: false,\n            labelFormatter: null, // fn: string -> string\n            container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n            position: 'ne', // position of default legend container within plot\n            margin: 5, // distance from grid edge to default legend container within plot\n            sorted: null // default to no legend sorting\n        }\n    };\n\n    function insertLegend(plot, options, placeholder, legendEntries) {\n        // clear before redraw\n        if (options.legend.container != null) {\n            $(options.legend.container).html('');\n        } else {\n            placeholder.find('.legend').remove();\n        }\n\n        if (!options.legend.show) {\n            return;\n        }\n\n        // Save the legend entries in legend options\n        var entries = options.legend.legendEntries = legendEntries,\n            plotOffset = options.legend.plotOffset = plot.getPlotOffset(),\n            html = [],\n            entry, labelHtml, iconHtml,\n            maxLabelLength = 0,\n            j = 0,\n            pos = \"\",\n            p = options.legend.position,\n            m = options.legend.margin,\n            shape = {\n                name: '',\n                label: '',\n                xPos: '',\n                yPos: ''\n            };\n\n        html[j++] = '<svg class=\"legendLayer\" style=\"width:inherit;height:inherit;\">';\n        html[j++] = '<rect class=\"background\" width=\"100%\" height=\"100%\"/>';\n        html[j++] = svgShapeDefs;\n\n        // Generate html for icons and labels from a list of entries\n        for (var i = 0; i < entries.length; ++i) {\n            entry = entries[i];\n            iconHtml = '';\n            shape.label = entry.label;\n            shape.xPos = '0em';\n            shape.yPos = i * 1.5 + 'em';\n            // area\n            if (entry.options.lines.show && entry.options.lines.fill) {\n                shape.name = 'area';\n                shape.fillColor = entry.color;\n                iconHtml += getEntryIconHtml(shape);\n            }\n            // bars\n            if (entry.options.bars.show) {\n                shape.name = 'bar';\n                shape.fillColor = entry.color;\n                iconHtml += getEntryIconHtml(shape);\n            }\n            // lines\n            if (entry.options.lines.show && !entry.options.lines.fill) {\n                shape.name = 'line';\n                shape.strokeColor = entry.color;\n                shape.strokeWidth = entry.options.lines.lineWidth;\n                iconHtml += getEntryIconHtml(shape);\n            }\n            // points\n            if (entry.options.points.show) {\n                shape.name = entry.options.points.symbol;\n                shape.strokeColor = entry.color;\n                shape.fillColor = entry.options.points.fillColor;\n                shape.strokeWidth = entry.options.points.lineWidth;\n                iconHtml += getEntryIconHtml(shape);\n            }\n\n            maxLabelLength = maxLabelLength < shape.label.length ? shape.label.length : maxLabelLength;\n            labelHtml = '<text x=\"' + shape.xPos + '\" y=\"' + shape.yPos + '\" text-anchor=\"start\"><tspan dx=\"2em\" dy=\"1.2em\">' + shape.label + '</tspan></text>'\n            html[j++] = '<g>' + iconHtml + labelHtml + '</g>';\n        }\n\n        html[j++] = '</svg>';\n        if (m[0] == null) {\n            m = [m, m];\n        }\n\n        if (p.charAt(0) === 'n') {\n            pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n        } else if (p.charAt(0) === 's') {\n            pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n        }\n\n        if (p.charAt(1) === 'e') {\n            pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n        } else if (p.charAt(1) === 'w') {\n            pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n        }\n\n        var legendEl,\n            width = 3 + maxLabelLength / 2,\n            height = entries.length * 1.6;\n        if (!options.legend.container) {\n            legendEl = $('<div class=\"legend\" style=\"position:absolute;' + pos + '\">' + html.join('') + '</div>').appendTo(placeholder);\n            legendEl.css('width', width + 'em');\n            legendEl.css('height', height + 'em');\n            legendEl.css('pointerEvents', 'none');\n        } else {\n            legendEl = $(html.join('')).appendTo(options.legend.container)[0];\n            options.legend.container.style.width = width + 'em';\n            options.legend.container.style.height = height + 'em';\n        }\n    }\n\n    // Generate html for a shape\n    function getEntryIconHtml(shape) {\n        var html = '',\n            name = shape.name,\n            x = shape.xPos,\n            y = shape.yPos,\n            fill = shape.fillColor,\n            stroke = shape.strokeColor,\n            width = shape.strokeWidth;\n        switch (name) {\n            case 'circle':\n                html = '<use xlink:href=\"#circle\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'diamond':\n                html = '<use xlink:href=\"#diamond\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'cross':\n                html = '<use xlink:href=\"#cross\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    // 'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'rectangle':\n                html = '<use xlink:href=\"#rectangle\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'plus':\n                html = '<use xlink:href=\"#plus\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    // 'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'bar':\n                html = '<use xlink:href=\"#bars\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    // 'stroke=\"' + stroke + '\" ' +\n                    // 'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'area':\n                html = '<use xlink:href=\"#area\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    // 'stroke=\"' + stroke + '\" ' +\n                    // 'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'line':\n                html = '<use xlink:href=\"#line\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    // 'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            default:\n                // default is circle\n                html = '<use xlink:href=\"#circle\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n        }\n\n        return html;\n    }\n\n    // Define svg symbols for shapes\n    var svgShapeDefs = '' +\n        '<defs>' +\n            '<symbol id=\"line\" fill=\"none\" viewBox=\"-5 -5 25 25\">' +\n                '<polyline points=\"0,15 5,5 10,10 15,0\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"area\" stroke-width=\"1\" viewBox=\"-5 -5 25 25\">' +\n                '<polyline points=\"0,15 5,5 10,10 15,0, 15,15, 0,15\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"bars\" stroke-width=\"1\" viewBox=\"-5 -5 25 25\">' +\n                '<polyline points=\"1.5,15.5 1.5,12.5, 4.5,12.5 4.5,15.5 6.5,15.5 6.5,3.5, 9.5,3.5 9.5,15.5 11.5,15.5 11.5,7.5 14.5,7.5 14.5,15.5 1.5,15.5\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"circle\" viewBox=\"-5 -5 25 25\">' +\n                '<circle cx=\"0\" cy=\"15\" r=\"2.5\"/>' +\n                '<circle cx=\"5\" cy=\"5\" r=\"2.5\"/>' +\n                '<circle cx=\"10\" cy=\"10\" r=\"2.5\"/>' +\n                '<circle cx=\"15\" cy=\"0\" r=\"2.5\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"rectangle\" viewBox=\"-5 -5 25 25\">' +\n                '<rect x=\"-2.1\" y=\"12.9\" width=\"4.2\" height=\"4.2\"/>' +\n                '<rect x=\"2.9\" y=\"2.9\" width=\"4.2\" height=\"4.2\"/>' +\n                '<rect x=\"7.9\" y=\"7.9\" width=\"4.2\" height=\"4.2\"/>' +\n                '<rect x=\"12.9\" y=\"-2.1\" width=\"4.2\" height=\"4.2\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"diamond\" viewBox=\"-5 -5 25 25\">' +\n                '<path d=\"M-3,15 L0,12 L3,15, L0,18 Z\"/>' +\n                '<path d=\"M2,5 L5,2 L8,5, L5,8 Z\"/>' +\n                '<path d=\"M7,10 L10,7 L13,10, L10,13 Z\"/>' +\n                '<path d=\"M12,0 L15,-3 L18,0, L15,3 Z\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"cross\" fill=\"none\" viewBox=\"-5 -5 25 25\">' +\n                '<path d=\"M-2.1,12.9 L2.1,17.1, M2.1,12.9 L-2.1,17.1 Z\"/>' +\n                '<path d=\"M2.9,2.9 L7.1,7.1 M7.1,2.9 L2.9,7.1 Z\"/>' +\n                '<path d=\"M7.9,7.9 L12.1,12.1 M12.1,7.9 L7.9,12.1 Z\"/>' +\n                '<path d=\"M12.9,-2.1 L17.1,2.1 M17.1,-2.1 L12.9,2.1 Z\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"plus\" fill=\"none\" viewBox=\"-5 -5 25 25\">' +\n                '<path d=\"M0,12 L0,18, M-3,15 L3,15 Z\"/>' +\n                '<path d=\"M5,2 L5,8 M2,5 L8,5 Z\"/>' +\n                '<path d=\"M10,7 L10,13 M7,10 L13,10 Z\"/>' +\n                '<path d=\"M15,-3 L15,3 M12,0 L18,0 Z\"/>' +\n            '</symbol>' +\n        '</defs>';\n\n    // Generate a list of legend entries in their final order\n    function getLegendEntries(series, labelFormatter, sorted) {\n        var lf = labelFormatter,\n            legendEntries = series.map(function(s, i) {\n                return {\n                    label: (lf ? lf(s.label, s) : s.label) || 'Plot ' + (i + 1),\n                    color: s.color,\n                    options: {\n                        lines: s.lines,\n                        points: s.points,\n                        bars: s.bars\n                    }\n                };\n            });\n\n        // Sort the legend using either the default or a custom comparator\n        if (sorted) {\n            if ($.isFunction(sorted)) {\n                legendEntries.sort(sorted);\n            } else if (sorted === 'reverse') {\n                legendEntries.reverse();\n            } else {\n                var ascending = (sorted !== 'descending');\n                legendEntries.sort(function(a, b) {\n                    return a.label === b.label\n                        ? 0\n                        : ((a.label < b.label) !== ascending ? 1 : -1 // Logical XOR\n                        );\n                });\n            }\n        }\n\n        return legendEntries;\n    }\n\n    // return false if opts1 same as opts2\n    function checkOptions(opts1, opts2) {\n        for (var prop in opts1) {\n            if (opts1.hasOwnProperty(prop)) {\n                if (opts1[prop] !== opts2[prop]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    // Compare two lists of legend entries\n    function shouldRedraw(oldEntries, newEntries) {\n        if (!oldEntries || !newEntries) {\n            return true;\n        }\n\n        if (oldEntries.length !== newEntries.length) {\n            return true;\n        }\n        var i, newEntry, oldEntry, newOpts, oldOpts;\n        for (i = 0; i < newEntries.length; i++) {\n            newEntry = newEntries[i];\n            oldEntry = oldEntries[i];\n\n            if (newEntry.label !== oldEntry.label) {\n                return true;\n            }\n\n            if (newEntry.color !== oldEntry.color) {\n                return true;\n            }\n\n            // check for changes in lines options\n            newOpts = newEntry.options.lines;\n            oldOpts = oldEntry.options.lines;\n            if (checkOptions(newOpts, oldOpts)) {\n                return true;\n            }\n\n            // check for changes in points options\n            newOpts = newEntry.options.points;\n            oldOpts = oldEntry.options.points;\n            if (checkOptions(newOpts, oldOpts)) {\n                return true;\n            }\n\n            // check for changes in bars options\n            newOpts = newEntry.options.bars;\n            oldOpts = oldEntry.options.bars;\n            if (checkOptions(newOpts, oldOpts)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function init(plot) {\n        plot.hooks.setupGrid.push(function (plot) {\n            var options = plot.getOptions();\n            var series = plot.getData(),\n                labelFormatter = options.legend.labelFormatter,\n                oldEntries = options.legend.legendEntries,\n                oldPlotOffset = options.legend.plotOffset,\n                newEntries = getLegendEntries(series, labelFormatter, options.legend.sorted),\n                newPlotOffset = plot.getPlotOffset();\n\n            if (shouldRedraw(oldEntries, newEntries) ||\n                checkOptions(oldPlotOffset, newPlotOffset)) {\n                insertLegend(plot, options, plot.getPlaceholder(), newEntries);\n            }\n        });\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: defaultOptions,\n        name: 'legend',\n        version: '1.0'\n    });\n})(jQuery);\n"]}