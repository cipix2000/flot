<html>
<head>
    <link rel="stylesheet" type="text/css" href="style.css" />
    <style>
        acircle {
            fill: red;
        }
        #c1 {
            fill: white;
        }
        #c2 {
            fill: black;
        }
        #c3 {
            fill: yellow;
        }
    </style>
</head>
<body bgcolor="#DDDDDD">
  <!--<input type="button" value="Compose images" title="This will call the function to compose images." onclick="composeImagesOnClick();"> -->
  <input type="button" value="Test promises" title="This will test promises." onclick="testPromisesOnClick();">
  <canvas id="canvasSource" width="100" height="100" title="canvasSource"></canvas>
  <svg id="svgSource" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" width="100" height="100" title="svg">
    <circle id="c1" cx="10" cy="10" r="5" style="fill:red"/>
    <circle id="c2" cx="30" cy="40" r="7" style="fill:#00FF00"/>
    <circle id="c3" cx="50" cy="70" r="9" style="fill:blue"/>
  </svg>
  <img id="canvasDestination" width="100" height="100" title="canvasDestination"></img>
  <img id="svgDestination" width="100" height="100" title="svgDestination"></img>
  <table border="1"><tr><td><canvas id="destination" width="300" height="300" title="destination"></canvas></td></tr></table>
  <a id="downloadElement" href="link here" download>Download merged image</a>
  <script>

    // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
    //
    // Opera 8.0+
    var isOpera = (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;

    // Firefox 1.0+
    var isFirefox = typeof InstallTrigger !== 'undefined';

    // Safari 3.0+ "[object HTMLElementConstructor]"
    var isSafari = /constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || (typeof safari !== 'undefined' && safari.pushNotification));

    // Internet Explorer 6-11
    var isIE = /*@cc_on!@*/false || !!document.documentMode;

    // Edge 20+
    var isEdge = !isIE && !!window.StyleMedia;

    // Chrome 1+
    var isChrome = !!window.chrome && !!window.chrome.webstore;

    // Blink engine detection
    var isBlink = (isChrome || isOpera) && !!window.CSS;
    // ***

    function writeSomethingToCanvas(canvas) {
        var ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(99, 99);
        ctx.moveTo(30, 60);
        ctx.lineTo(70, 40);
        ctx.stroke();
        //ctx.rectangle(0, 0, 99, 99);
    }

    function copyCanvasToImg(canvas, img) {
        img.src = canvas.toDataURL('image/png');
    }

    function getCSSRules(document) {
        var styleSheets = document.styleSheets,
            rulesList = [];
        for (var i = 0; i < styleSheets.length; i++) {
            // in Chrome the external CSS files are empty when the page is loaded from directly disk
            var rules = styleSheets[i].cssRules || [];
            for (var j = 0; j < rules.length; j++) {
                var rule = rules[j];
                rulesList.push(rule.cssText);
            }
        }
        return rulesList;
    }

    function embedCSSRulesInSVG(rules, svg) {
        var text = [
            '<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">',
            '<style>',
            '/* <![CDATA[ */',
            rules.join('\n'),
            '/* ]]> */',
            '</style>',
            svg.innerHTML,
            '</svg>'
        ].join('\n');
        return text;
    }

    function copySVGToImgMostBrowsers(svg, img) {
        var rules = getCSSRules(document),
            text = embedCSSRulesInSVG(rules, svg),
            blob = new Blob([text], {type:"image/svg+xml;charset=utf-8"}),
            domURL = self.URL || self.webkitURL || self,
            url = domURL.createObjectURL(blob);
        img.src = url;
    }

    function copySVGToImgSafari(svg, img) {
        var rules = getCSSRules(document),
            text = embedCSSRulesInSVG(rules, svg),
            data = "data:image/svg+xml;base64," + btoa(text);
        img.src = data;
    }

    function copySVGToImg(svg, img) {
        if (isEdge || isIE || isFirefox || isOpera || isChrome) {
            copySVGToImgMostBrowsers(svg, img);
        } else {
            copySVGToImgSafari(svg, img);
        }
    }


    function prepareImagesToBeComposed(sources, destination) {
        var Result = 0;
        if (sources.length === 0) {
            Result = -1; //nothing to do if called without sources
        } else {
            ///////////////////////????????????????????????????? use offsetLeft and offsetTop properties instead of getBoundingClientRect().left  and getBoundingClientRect().top ???   https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
            var minX = sources[0].getBoundingClientRect().left;
            var minY = sources[0].getBoundingClientRect().top;
            var maxX = sources[0].getBoundingClientRect().right;
            var maxY = sources[0].getBoundingClientRect().bottom;

            for (var i = 1; i < sources.length; i++) {
                if (minX > sources[i].getBoundingClientRect().left) {
                    minX = sources[i].getBoundingClientRect().left;
                }

                if (minY > sources[i].getBoundingClientRect().top) {
                    minY = sources[i].getBoundingClientRect().top;
                }
            }

            for (var i = 1; i < sources.length; i++) {
                if (maxX < sources[i].getBoundingClientRect().right) {
                    maxX = sources[i].getBoundingClientRect().right;
                }

                if (maxY < sources[i].getBoundingClientRect().bottom) {
                    maxY = sources[i].getBoundingClientRect().bottom;
                }
            }

            //console.log("destination.width = " + destination.width + "     destination.height = " + destination.height);
            if ((maxX - minX <= 0) || (maxY - minY <= 0)) {
                Result = -2;
            } else {
                destination.width = maxX - minX;
                destination.height = maxY - minY;
                //console.log("destination.width = " + destination.width + "     destination.height = " + destination.height);

                //console.log("minX = " + minX + "     minY = " + minY);
                for (var i = 0; i < sources.length; i++) {
                    sources[i]["xCompOffset"] = sources[i].getBoundingClientRect().left - minX;
                    sources[i]["yCompOffset"] = sources[i].getBoundingClientRect().top - minY;
                }
            }
        }
        return Result;
    }


    function copyImgsToCanvas(sources, destination) {
        var prepareImagesResult = prepareImagesToBeComposed(sources, destination);
        if (prepareImagesResult === 0) {
            var destinationCtx = destination.getContext('2d');

            for (var i = 0; i < sources.length; i++) {
                destinationCtx.drawImage(sources[i], sources[i].xCompOffset, sources[i].yCompOffset);
            }
        }
        return prepareImagesResult;
    }


    function setDownloadableImgRef(linkElement, img) {
        linkElement.href = img.toDataURL('image/png');
    }


    var originalCanvas = document.getElementById('canvasSource'),
        originalSvg = document.getElementById('svgSource'),
        tempImg1 = document.getElementById('canvasDestination'),
        tempImg2 = document.getElementById('svgDestination'),
        destinationImg = document.getElementById('destination'),
        linkElement = document.getElementById('downloadElement');


        //var tempImg1 = new Image;
        tempImg1.width = 100;
        tempImg1.height = 100;

        tempImg1["offsetLeft"] = 216;
        tempImg1["offsetTop"] = 8;

        console.log("tempImg1.offsetLeft = " + tempImg1.offsetLeft);
        console.log("tempImg1.offsetTop = " + tempImg1.offsetTop);

        //var tempImg2 = new Image;
        tempImg2.width = 100;
        tempImg2.height = 100;


        //console.log("tempImg1.hidden = " + tempImg1.hidden);
        //console.log("tempImg2.hidden = " + tempImg2.hidden);

        //tempImg1.hidden = true;
        //tempImg2.hidden = true;
    console.log("before writeSomethingToCanvas");
    writeSomethingToCanvas(originalCanvas);
    console.log("after writeSomethingToCanvas");


    var onCopyCount = 0;
    var onCopyTotalCount = 0;
    var generatedTempImages = [tempImg1, tempImg2]; ////////////////////////////////////////// should be initialized with empty


    function generateTempImageFromCanvasOrSvg(srcCanvasOrSvg, destImg) {
        if (srcCanvasOrSvg.tagName === "CANVAS") {
            copyCanvasToImg(srcCanvasOrSvg, destImg);
        }

        if (srcCanvasOrSvg.tagName === "svg") {
            copySVGToImg(srcCanvasOrSvg, destImg);
        }
    }


///// ToDo: generate the array of tempImg sources (i.e. generatedTempImages) from canvasOrSvgSources, using a for loop. This array should be passed to copyImgsToCanvas.
///// Every image from generatedTempImages array should have extra properties, used by prepareImagesToBeComposed function, instead of left, top, right, bottom.

    var allPromises = [];


    function getFinalSuccessCallback(tempImgs, destination) {
        return function finalSuccessCallback(result) {
          console.log("successCallback succeeded with " + result);
          var compositionResult = copyImgsToCanvas(tempImgs, destination);
          setDownloadableImgRef(linkElement, destinationImg);
          return "Done. compositionResult = " + compositionResult;
      };
    }

    function failureCallback(error) {
      console.log("failureCallback failed with " + error);
    }


    function getDoSomething(tempImg, canvasOrSvgSource) {
        return function doSomething(successCallbackFunc, failureCallbackFunc) {
            console.log("entering from doSomething");
            tempImg.onload = successCallbackFunc;
            generateTempImageFromCanvasOrSvg(canvasOrSvgSource, tempImg);
            console.log("exiting doSomething");
        };
    }


    function manyPromises(canvasOrSvgSources) {
        var tempImgs = [tempImg1, tempImg2];
        for (var i = 0; i < canvasOrSvgSources.length; i++) {
            var currentPromise = new Promise(getDoSomething(tempImgs[i], canvasOrSvgSources[i]));
            allPromises.push(currentPromise);
        }
        var lastPromise = Promise.all(allPromises).then(getFinalSuccessCallback(tempImgs, destinationImg), failureCallback);
        console.log("lastPromise is:")
        console.log(lastPromise);
        console.log("exiting manyPromises");
        return lastPromise;
    }


    async function asyncManyPromises() {
        var sources = [originalCanvas, originalSvg];
        var asynResult = await manyPromises(sources);
        console.log("asynResult is: " + asynResult);
    }


    function testPromisesOnClick() {
        asyncManyPromises();
    }

  </script>
</body>
</html>
