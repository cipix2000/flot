<html>
<head>
    <link rel="stylesheet" type="text/css" href="style.css" />
    <style>
        acircle {
            fill: red;
        }
        #c1 {
            fill: white;
        }
        #c2 {
            fill: black;
        }
        #c3 {
            fill: yellow;
        }
    </style>
</head>
<body bgcolor="#DDDDDD">
  <input type="button" value="Compose images" title="This will call the function to compose images." onclick="composeImagesOnClick();">
  <input type="button" value="Test promises" title="This will test promises." onclick="testPromisesOnClick();">
  <canvas id="canvasSource" width="100" height="100" title="canvasSource"></canvas>
  <svg id="svgSource" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" width="100" height="100" title="svg">
    <circle id="c1" cx="10" cy="10" r="5" style="fill:red"/>
    <circle id="c2" cx="30" cy="40" r="7" style="fill:#00FF00"/>
    <circle id="c3" cx="50" cy="70" r="9" style="fill:blue"/>
  </svg>
  <img id="canvasDestination" width="100" height="100" title="canvasDestination"></img>
  <img id="svgDestination" width="100" height="100" title="svgDestination"></img>
  <table border="1"><tr><td><canvas id="destination" width="300" height="300" title="destination"></canvas></td></tr></table>
  <a id="downloadElement" href="link here" download>Download merged image</a>
  <script>

    // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
    //
    // Opera 8.0+
    var isOpera = (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;

    // Firefox 1.0+
    var isFirefox = typeof InstallTrigger !== 'undefined';

    // Safari 3.0+ "[object HTMLElementConstructor]"
    var isSafari = /constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || (typeof safari !== 'undefined' && safari.pushNotification));

    // Internet Explorer 6-11
    var isIE = /*@cc_on!@*/false || !!document.documentMode;

    // Edge 20+
    var isEdge = !isIE && !!window.StyleMedia;

    // Chrome 1+
    var isChrome = !!window.chrome && !!window.chrome.webstore;

    // Blink engine detection
    var isBlink = (isChrome || isOpera) && !!window.CSS;
    // ***

    function writeSomethingToCanvas(canvas) {
        var ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(99, 99);
        ctx.moveTo(30, 60);
        ctx.lineTo(70, 40);
        ctx.stroke();
        //ctx.rectangle(0, 0, 99, 99);
    }

    function copyCanvasToImg(canvas, img, onCopyCanvasDone) {
        img.src = canvas.toDataURL('image/png');
        //img.onload = onCopyCanvasDone;
    }

    function getCSSRules(document) {
        var styleSheets = document.styleSheets,
            rulesList = [];
        for (var i = 0; i < styleSheets.length; i++) {
            // in Chrome the external CSS files are empty when the page is loaded from directly disk
            var rules = styleSheets[i].cssRules || [];
            for (var j = 0; j < rules.length; j++) {
                var rule = rules[j];
                rulesList.push(rule.cssText);
            }
        }
        return rulesList;
    }

    function embedCSSRulesInSVG(rules, svg) {
        var text = [
            '<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">',
            '<style>',
            '/* <![CDATA[ */',
            rules.join('\n'),
            '/* ]]> */',
            '</style>',
            svg.innerHTML,
            '</svg>'
        ].join('\n');
        return text;
    }

    function copySVGToImgMostBrowsers(svg, img, onCopySVGDone) {
        var rules = getCSSRules(document),
            text = embedCSSRulesInSVG(rules, svg),
            blob = new Blob([text], {type:"image/svg+xml;charset=utf-8"}),
            domURL = self.URL || self.webkitURL || self,
            url = domURL.createObjectURL(blob);
        img.src = url;
        //img.onload = onCopySVGDone;
    }

    function copySVGToImgSafari(svg, img) {
        var rules = getCSSRules(document),
            text = embedCSSRulesInSVG(rules, svg),
            data = "data:image/svg+xml;base64," + btoa(text);
        img.src = data;
    }

    function copySVGToImg(svg, img, onCopySVGDone) {
        if (isEdge || isIE || isFirefox || isOpera || isChrome) {
            copySVGToImgMostBrowsers(svg, img, onCopySVGDone);
        } else {
            copySVGToImgSafari(svg, img);
        }
    }


    function prepareImagesToBeComposed(sources, destination) {
        var Result = 0;
        if (sources.length === 0) {
            Result = -1; //nothing to do if called without sources
        } else {
            ///////////////////////????????????????????????????? use offsetLeft and offsetTop properties instead of getBoundingClientRect().left  and getBoundingClientRect().top ???   https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
            var minX = sources[0].getBoundingClientRect().left;
            var minY = sources[0].getBoundingClientRect().top;
            var maxX = sources[0].getBoundingClientRect().right;
            var maxY = sources[0].getBoundingClientRect().bottom;

            for (var i = 1; i < sources.length; i++) {
                if (minX > sources[i].getBoundingClientRect().left) {
                    minX = sources[i].getBoundingClientRect().left;
                }

                if (minY > sources[i].getBoundingClientRect().top) {
                    minY = sources[i].getBoundingClientRect().top;
                }
            }

            for (var i = 1; i < sources.length; i++) {
                if (maxX < sources[i].getBoundingClientRect().right) {
                    maxX = sources[i].getBoundingClientRect().right;
                }

                if (maxY < sources[i].getBoundingClientRect().bottom) {
                    maxY = sources[i].getBoundingClientRect().bottom;
                }
            }

            //console.log("destination.width = " + destination.width + "     destination.height = " + destination.height);
            if ((maxX - minX <= 0) || (maxY - minY <= 0)) {
                Result = -2;
            } else {
                destination.width = maxX - minX;
                destination.height = maxY - minY;
                //console.log("destination.width = " + destination.width + "     destination.height = " + destination.height);

                //console.log("minX = " + minX + "     minY = " + minY);
                for (var i = 0; i < sources.length; i++) {
                    sources[i]["xCompOffset"] = sources[i].getBoundingClientRect().left - minX;
                    sources[i]["yCompOffset"] = sources[i].getBoundingClientRect().top - minY;
                }
            }
        }
        return Result;
    }


    function copyImgsToCanvas(sources, destination) {
        var prepareImagesResult = prepareImagesToBeComposed(sources, destination);
        if (prepareImagesResult === 0) {
            var destinationCtx = destination.getContext('2d');

            for (var i = 0; i < sources.length; i++) {
                destinationCtx.drawImage(sources[i], sources[i].xCompOffset, sources[i].yCompOffset);
            }
        }
        return prepareImagesResult;
    }


    function setDownloadableImgRef(linkElement, img) {
        linkElement.href = img.toDataURL('image/png');
    }


    var originalCanvas = document.getElementById('canvasSource'),
        originalSvg = document.getElementById('svgSource'),
        tempImg1 = document.getElementById('canvasDestination'),
        tempImg2 = document.getElementById('svgDestination'),
        destinationImg = document.getElementById('destination'),
        linkElement = document.getElementById('downloadElement');


        //var tempImg1 = new Image;
        tempImg1.width = 100;
        tempImg1.height = 100;

        tempImg1["offsetLeft"] = 216;
        tempImg1["offsetTop"] = 8;

        console.log("tempImg1.offsetLeft = " + tempImg1.offsetLeft);
        console.log("tempImg1.offsetTop = " + tempImg1.offsetTop);

        //var tempImg2 = new Image;
        tempImg2.width = 100;
        tempImg2.height = 100;


        //console.log("tempImg1.hidden = " + tempImg1.hidden);
        //console.log("tempImg2.hidden = " + tempImg2.hidden);

        //tempImg1.hidden = true;
        //tempImg2.hidden = true;
    console.log("before writeSomethingToCanvas");
    writeSomethingToCanvas(originalCanvas);
    console.log("after writeSomethingToCanvas");

    //copyCanvasToImg(originalCanvas, tempImg1, null);
    //copySVGToImg(originalSvg, tempImg2, null);

    //copyImgsToCanvas([tempImg1, tempImg2], destinationImg);
    /*
    setTimeout(function() {
        destinationImg.width = 100; //the width and height have to be set prior to calling copyImgsToCanvas. Otherwise, no image will be painted.
        destinationImg.height = 100;
        //var copyResult = copyImgsToCanvas([tempImg1, tempImg2], destinationImg);
        var copyResult = copyImgsToCanvas([originalCanvas, originalSvg], destinationImg);
        if (copyResult !== 0) {
            alert("Can't compose final image. Error: " + copyResult);
        }
        setDownloadableImgRef(linkElement, destinationImg);
    }, 200);
    */



    var onCopyCount = 0;
    var onCopyTotalCount = 0;
    var generatedTempImages = [tempImg1, tempImg2]; ////////////////////////////////////////// should be initialized with empty


    function onCopySVGDone() {
        console.log('onload is working for SVG');
        console.log('Res = ' + composeImages());
    }

    function onCopyCanvasDone() {
        console.log('onload is working for Canvas');
        //console.log('Res = ' + composeImages());
    }

    function onCopyCanvasOrSVGDone() {
        console.log('onload is working for Canvas or SVG');
        onCopyCount++;
        if (onCopyCount >= onCopyTotalCount) {
            composeImages();
            onCopyCount = 0;
        }
    }


    function generateTempImageFromCanvasOrSvg(srcCanvasOrSvg, destImg, onCopyDone) {
        if (srcCanvasOrSvg.tagName === "CANVAS") {
            copyCanvasToImg(srcCanvasOrSvg, destImg, onCopyDone);
        }

        if (srcCanvasOrSvg.tagName === "svg") {
            copySVGToImg(srcCanvasOrSvg, destImg, onCopyDone);
        }
    }


    function generateTempImages(canvasOrSvgSources, destination) {
        onCopyTotalCount = canvasOrSvgSources.length; //two images will call event handlers
        onCopyCount = 0;
        ///// ToDo: generate the array of tempImg sources (i.e. generatedTempImages) from canvasOrSvgSources, using a for loop. This array should be passed to copyImgsToCanvas.
        ///// Every image from generatedTempImages array should have extra properties, used by prepareImagesToBeComposed function, instead of left, top, right, bottom.
        generateTempImageFromCanvasOrSvg(originalCanvas, generatedTempImages[0], onCopyCanvasOrSVGDone);
        generateTempImageFromCanvasOrSvg(originalSvg, generatedTempImages[1], onCopyCanvasOrSVGDone);
    }


    function composeImages() {
        destinationImg.width = 100; //the width and height have to be set prior to calling copyImgsToCanvas. Otherwise, no image will be painted.
        destinationImg.height = 100;
        var copyResult = copyImgsToCanvas(generatedTempImages, destinationImg);
        if (copyResult !== 0) {
            alert("Can't compose final image. Error: " + copyResult);
        }
        setDownloadableImgRef(linkElement, destinationImg);
        return copyResult;
    }

    function composeImagesOnClick() {
        generateTempImages([originalCanvas, originalSvg], destinationImg);
        console.log("Exiting composeImagesOnClick");
    }





    var allPromises = [];
    var mySharedValue = 0;



    function getFinalSuccessCallback(tempImgs, destination) {
        return function finalSuccessCallback(result) {
          console.log("successCallback succeeded with " + result);
          copyImgsToCanvas(tempImgs, destination);
          return "URA!!!";
      };
    }

    function failureCallback(error) {
      console.log("failureCallback failed with " + error);
    }
/*
    function doSomethingOLD(successCallbackFunc, failureCallbackFunc) {
        console.log("entering from doSomething");
        console.log("mySharedValue = " + mySharedValue);
        tempImg1.onload = successCallbackFunc;
        tempImg1.src = 'empty.png';
        console.log("exiting doSomething");
    };
*/
    function getDoSomething(tempImg, source) {
        return function doSomething(successCallbackFunc, failureCallbackFunc) {
            console.log("entering from doSomething");
            console.log("mySharedValue = " + mySharedValue);
            tempImg.onload = successCallbackFunc;
            generateTempImageFromCanvasOrSvg(source, tempImg);
            console.log("exiting doSomething");
        };
    }


    function manyPromises() {
        var sources = [originalCanvas, originalSvg],
            tempImgs = [tempImg1, tempImg2];
        for (var i = 0; i < sources.length; i++) {
            mySharedValue = i;
            var currentPromise = new Promise(getDoSomething(tempImgs[i], sources[i]));
            allPromises.push(currentPromise);
        }
        var lastPromise = Promise.all(allPromises).then(getFinalSuccessCallback(tempImgs, destinationImg), failureCallback);
        console.log("lastPromise is:")
        console.log(lastPromise);
        console.log("exiting manyPromises");
        return lastPromise;
    }


    async function asyncManyPromises() {
        //generateTempImageFromCanvasOrSvg(originalCanvas, tempImg1, null);
        //generateTempImageFromCanvasOrSvg(originalSvg, tempImg2, null);

        var asynResult = await manyPromises();
        console.log("asynResult is: " + asynResult);
    }


    function testPromisesOnClick() {
        /*console.log("========");
        console.log("entering testPromisesOnClick");
        var myPromise = new Promise(doSomething);
        console.log("after creating the first promise");
        myPromise.then(successCallback, failureCallback);
        console.log("...");
        myPromise = new Promise(doSomething);
        console.log("after creating the second promise");
        myPromise.then(successCallback, failureCallback);
        console.log("exiting testPromisesOnClick");
        console.log("..........");*/

        asyncManyPromises();

        /* log:
        entering testPromisesOnClick
        called from doSomething
        exiting doSomething
        after creating the first promise
        ...
        called from doSomething
        exiting doSomething
        after creating the second promise
        exiting testPromisesOnClick
        It succeeded with 10
        It succeeded with 10
        */
    }

  </script>
</body>
</html>
